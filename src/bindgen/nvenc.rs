/* automatically generated by rust-bindgen 0.59.2 */

// Generated through nvenc-sys build script

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NVENCAPI_MAJOR_VERSION: u32 = 11;
pub const NVENCAPI_MINOR_VERSION: u32 = 1;
pub const NVENCAPI_VERSION: u32 = 16777227;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " \\struct GUID"]
#[doc = " Abstracts the GUID structure for non-windows platforms."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct GUID {
    #[doc = "< [in]: Specifies the first 8 hexadecimal digits of the GUID."]
    pub Data1: u32,
    #[doc = "< [in]: Specifies the first group of 4 hexadecimal digits."]
    pub Data2: u16,
    #[doc = "< [in]: Specifies the second group of 4 hexadecimal digits."]
    pub Data3: u16,
    #[doc = "< [in]: Array of 8 bytes. The first 2 bytes contain the third group of 4 hexadecimal digits."]
    #[doc = "The remaining 6 bytes contain the final 12 hexadecimal digits."]
    pub Data4: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_GUID() {
    assert_eq!(
        ::std::mem::size_of::<GUID>(),
        16usize,
        concat!("Size of: ", stringify!(GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(GUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data4)
        )
    );
}
#[doc = " \\struct _NVENC_RECT"]
#[doc = " Defines a Rectangle. Used in ::NV_ENC_PREPROCESS_FRAME."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_RECT {
    #[doc = "< [in]: X coordinate of the upper left corner of rectangular area to be specified."]
    pub left: u32,
    #[doc = "< [in]: Y coordinate of the upper left corner of the rectangular area to be specified."]
    pub top: u32,
    #[doc = "< [in]: X coordinate of the bottom right corner of the rectangular area to be specified."]
    pub right: u32,
    #[doc = "< [in]: Y coordinate of the bottom right corner of the rectangular area to be specified."]
    pub bottom: u32,
}
#[test]
fn bindgen_test_layout__NVENC_RECT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_RECT>(),
        16usize,
        concat!("Size of: ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_RECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NVENC_RECT>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NVENC_RECT>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NVENC_RECT>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NVENC_RECT>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " \\struct _NVENC_RECT"]
#[doc = " Defines a Rectangle. Used in ::NV_ENC_PREPROCESS_FRAME."]
pub type NVENC_RECT = _NVENC_RECT;
#[doc = " @}"]
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[doc = " Input frame encode modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    #[doc = "< Frame mode"]
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME = 1,
    #[doc = "< Field mode"]
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD = 2,
    #[doc = "< MB adaptive frame/field"]
    NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF = 3,
}
#[doc = " Input frame encode modes"]
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
#[repr(u32)]
#[doc = " Rate Control Modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_RC_MODE {
    #[doc = "< Constant QP mode"]
    NV_ENC_PARAMS_RC_CONSTQP = 0,
    #[doc = "< Variable bitrate mode"]
    NV_ENC_PARAMS_RC_VBR = 1,
    #[doc = "< Constant bitrate mode"]
    NV_ENC_PARAMS_RC_CBR = 2,
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION +"]
    #[doc = "lowDelayKeyFrameScale=1"]
    NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ = 8,
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
    NV_ENC_PARAMS_RC_CBR_HQ = 16,
    #[doc = "< Deprecated, use NV_ENC_PARAMS_RC_VBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
    NV_ENC_PARAMS_RC_VBR_HQ = 32,
}
#[doc = " Rate Control Modes"]
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
#[repr(u32)]
#[doc = " Multi Pass encoding"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MULTI_PASS {
    #[doc = "< Single Pass"]
    NV_ENC_MULTI_PASS_DISABLED = 0,
    #[doc = "< Two Pass encoding is enabled where first Pass is quarter resolution"]
    NV_ENC_TWO_PASS_QUARTER_RESOLUTION = 1,
    #[doc = "< Two Pass encoding is enabled where first Pass is full resolution"]
    NV_ENC_TWO_PASS_FULL_RESOLUTION = 2,
}
#[doc = " Multi Pass encoding"]
pub use self::_NV_ENC_MULTI_PASS as NV_ENC_MULTI_PASS;
#[repr(u32)]
#[doc = " Emphasis Levels"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_EMPHASIS_MAP_LEVEL {
    #[doc = "< Emphasis Map Level 0, for zero Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_0 = 0,
    #[doc = "< Emphasis Map Level 1, for very low Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_1 = 1,
    #[doc = "< Emphasis Map Level 2, for low Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_2 = 2,
    #[doc = "< Emphasis Map Level 3, for medium Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_3 = 3,
    #[doc = "< Emphasis Map Level 4, for high Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_4 = 4,
    #[doc = "< Emphasis Map Level 5, for very high Delta QP value"]
    NV_ENC_EMPHASIS_MAP_LEVEL_5 = 5,
}
#[doc = " Emphasis Levels"]
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
#[repr(u32)]
#[doc = " QP MAP MODE"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_QP_MAP_MODE {
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap have no effect."]
    NV_ENC_QP_MAP_DISABLED = 0,
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as Emphasis level. Currently this is only supported for H264"]
    NV_ENC_QP_MAP_EMPHASIS = 1,
    #[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP delta map."]
    NV_ENC_QP_MAP_DELTA = 2,
    #[doc = "< Currently This is not supported. Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP value."]
    NV_ENC_QP_MAP = 3,
}
#[doc = " QP MAP MODE"]
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
#[repr(u32)]
#[doc = " Input picture structure"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_STRUCT {
    #[doc = "< Progressive frame"]
    NV_ENC_PIC_STRUCT_FRAME = 1,
    #[doc = "< Field encoding top field first"]
    NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM = 2,
    #[doc = "< Field encoding bottom field first"]
    NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP = 3,
}
#[doc = " Input picture structure"]
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
#[repr(u32)]
#[doc = " Input picture type"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_TYPE {
    #[doc = "< Forward predicted"]
    NV_ENC_PIC_TYPE_P = 0,
    #[doc = "< Bi-directionally predicted picture"]
    NV_ENC_PIC_TYPE_B = 1,
    #[doc = "< Intra predicted picture"]
    NV_ENC_PIC_TYPE_I = 2,
    #[doc = "< IDR picture"]
    NV_ENC_PIC_TYPE_IDR = 3,
    #[doc = "< Bi-directionally predicted with only Intra MBs"]
    NV_ENC_PIC_TYPE_BI = 4,
    #[doc = "< Picture is skipped"]
    NV_ENC_PIC_TYPE_SKIPPED = 5,
    #[doc = "< First picture in intra refresh cycle"]
    NV_ENC_PIC_TYPE_INTRA_REFRESH = 6,
    #[doc = "< Non reference P picture"]
    NV_ENC_PIC_TYPE_NONREF_P = 7,
    #[doc = "< Picture type unknown"]
    NV_ENC_PIC_TYPE_UNKNOWN = 255,
}
#[doc = " Input picture type"]
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
#[repr(u32)]
#[doc = " Motion vector precisions"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MV_PRECISION {
    #[doc = "< Driver selects Quarter-Pel motion vector precision by default"]
    NV_ENC_MV_PRECISION_DEFAULT = 0,
    #[doc = "< Full-Pel motion vector precision"]
    NV_ENC_MV_PRECISION_FULL_PEL = 1,
    #[doc = "< Half-Pel motion vector precision"]
    NV_ENC_MV_PRECISION_HALF_PEL = 2,
    #[doc = "< Quarter-Pel motion vector precision"]
    NV_ENC_MV_PRECISION_QUARTER_PEL = 3,
}
#[doc = " Motion vector precisions"]
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
#[repr(u32)]
#[doc = " Input buffer formats"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_FORMAT {
    #[doc = "< Undefined buffer format"]
    NV_ENC_BUFFER_FORMAT_UNDEFINED = 0,
    #[doc = "< Semi-Planar YUV [Y plane followed by interleaved UV plane]"]
    NV_ENC_BUFFER_FORMAT_NV12 = 1,
    #[doc = "< Planar YUV [Y plane followed by V and U planes]"]
    NV_ENC_BUFFER_FORMAT_YV12 = 16,
    #[doc = "< Planar YUV [Y plane followed by U and V planes]"]
    NV_ENC_BUFFER_FORMAT_IYUV = 256,
    #[doc = "< Planar YUV [Y plane followed by U and V planes]"]
    NV_ENC_BUFFER_FORMAT_YUV444 = 4096,
    #[doc = "< 10 bit Semi-Planar YUV [Y plane followed by interleaved UV plane]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
    NV_ENC_BUFFER_FORMAT_YUV420_10BIT = 65536,
    #[doc = "< 10 bit Planar YUV444 [Y plane followed by U and V planes]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
    NV_ENC_BUFFER_FORMAT_YUV444_10BIT = 1048576,
    #[doc = "< 8 bit Packed A8R8G8B8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with B"]
    #[doc = "in the lowest 8 bits, G in the next 8 bits, R in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    NV_ENC_BUFFER_FORMAT_ARGB = 16777216,
    #[doc = "< 10 bit Packed A2R10G10B10. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with B"]
    #[doc = "in the lowest 10 bits, G in the next 10 bits, R in the"]
    #[doc = "10 bits after that and A in the highest 2 bits."]
    NV_ENC_BUFFER_FORMAT_ARGB10 = 33554432,
    #[doc = "< 8 bit Packed A8Y8U8V8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with V"]
    #[doc = "in the lowest 8 bits, U in the next 8 bits, Y in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    NV_ENC_BUFFER_FORMAT_AYUV = 67108864,
    #[doc = "< 8 bit Packed A8B8G8R8. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with R"]
    #[doc = "in the lowest 8 bits, G in the next 8 bits, B in the"]
    #[doc = "8 bits after that and A in the highest 8 bits."]
    NV_ENC_BUFFER_FORMAT_ABGR = 268435456,
    #[doc = "< 10 bit Packed A2B10G10R10. This is a word-ordered format"]
    #[doc = "where a pixel is represented by a 32-bit word with R"]
    #[doc = "in the lowest 10 bits, G in the next 10 bits, B in the"]
    #[doc = "10 bits after that and A in the highest 2 bits."]
    NV_ENC_BUFFER_FORMAT_ABGR10 = 536870912,
    #[doc = "< Buffer format representing one-dimensional buffer."]
    #[doc = "This format should be used only when registering the"]
    #[doc = "resource as output buffer, which will be used to write"]
    #[doc = "the encoded bit stream or H.264 ME only mode output."]
    NV_ENC_BUFFER_FORMAT_U8 = 1073741824,
}
#[doc = " Input buffer formats"]
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_60;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
#[repr(u32)]
#[doc = " Encoding levels"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_LEVEL {
    NV_ENC_LEVEL_AUTOSELECT = 0,
    NV_ENC_LEVEL_H264_1 = 10,
    NV_ENC_LEVEL_H264_1b = 9,
    NV_ENC_LEVEL_H264_11 = 11,
    NV_ENC_LEVEL_H264_12 = 12,
    NV_ENC_LEVEL_H264_13 = 13,
    NV_ENC_LEVEL_H264_2 = 20,
    NV_ENC_LEVEL_H264_21 = 21,
    NV_ENC_LEVEL_H264_22 = 22,
    NV_ENC_LEVEL_H264_3 = 30,
    NV_ENC_LEVEL_H264_31 = 31,
    NV_ENC_LEVEL_H264_32 = 32,
    NV_ENC_LEVEL_H264_4 = 40,
    NV_ENC_LEVEL_H264_41 = 41,
    NV_ENC_LEVEL_H264_42 = 42,
    NV_ENC_LEVEL_H264_5 = 50,
    NV_ENC_LEVEL_H264_51 = 51,
    NV_ENC_LEVEL_H264_52 = 52,
    NV_ENC_LEVEL_H264_60 = 60,
    NV_ENC_LEVEL_H264_61 = 61,
    NV_ENC_LEVEL_H264_62 = 62,
    NV_ENC_LEVEL_HEVC_21 = 63,
    NV_ENC_LEVEL_HEVC_3 = 90,
    NV_ENC_LEVEL_HEVC_31 = 93,
    NV_ENC_LEVEL_HEVC_4 = 120,
    NV_ENC_LEVEL_HEVC_41 = 123,
    NV_ENC_LEVEL_HEVC_5 = 150,
    NV_ENC_LEVEL_HEVC_51 = 153,
    NV_ENC_LEVEL_HEVC_52 = 156,
    NV_ENC_LEVEL_HEVC_6 = 180,
    NV_ENC_LEVEL_HEVC_61 = 183,
    NV_ENC_LEVEL_HEVC_62 = 186,
    NV_ENC_TIER_HEVC_HIGH = 1,
}
#[doc = " Encoding levels"]
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
#[repr(u32)]
#[doc = " Error Codes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NVENCSTATUS {
    #[doc = " This indicates that API call returned with no errors."]
    NV_ENC_SUCCESS = 0,
    #[doc = " This indicates that no encode capable devices were detected."]
    NV_ENC_ERR_NO_ENCODE_DEVICE = 1,
    #[doc = " This indicates that devices pass by the client is not supported."]
    NV_ENC_ERR_UNSUPPORTED_DEVICE = 2,
    #[doc = " This indicates that the encoder device supplied by the client is not"]
    #[doc = " valid."]
    NV_ENC_ERR_INVALID_ENCODERDEVICE = 3,
    #[doc = " This indicates that device passed to the API call is invalid."]
    NV_ENC_ERR_INVALID_DEVICE = 4,
    #[doc = " This indicates that device passed to the API call is no longer available and"]
    #[doc = " needs to be reinitialized. The clients need to destroy the current encoder"]
    #[doc = " session by freeing the allocated input output buffers and destroying the device"]
    #[doc = " and create a new encoding session."]
    NV_ENC_ERR_DEVICE_NOT_EXIST = 5,
    #[doc = " This indicates that one or more of the pointers passed to the API call"]
    #[doc = " is invalid."]
    NV_ENC_ERR_INVALID_PTR = 6,
    #[doc = " This indicates that completion event passed in ::NvEncEncodePicture() call"]
    #[doc = " is invalid."]
    NV_ENC_ERR_INVALID_EVENT = 7,
    #[doc = " This indicates that one or more of the parameter passed to the API call"]
    #[doc = " is invalid."]
    NV_ENC_ERR_INVALID_PARAM = 8,
    #[doc = " This indicates that an API call was made in wrong sequence/order."]
    NV_ENC_ERR_INVALID_CALL = 9,
    #[doc = " This indicates that the API call failed because it was unable to allocate"]
    #[doc = " enough memory to perform the requested operation."]
    NV_ENC_ERR_OUT_OF_MEMORY = 10,
    #[doc = " This indicates that the encoder has not been initialized with"]
    #[doc = " ::NvEncInitializeEncoder() or that initialization has failed."]
    #[doc = " The client cannot allocate input or output buffers or do any encoding"]
    #[doc = " related operation before successfully initializing the encoder."]
    NV_ENC_ERR_ENCODER_NOT_INITIALIZED = 11,
    #[doc = " This indicates that an unsupported parameter was passed by the client."]
    NV_ENC_ERR_UNSUPPORTED_PARAM = 12,
    #[doc = " This indicates that the ::NvEncLockBitstream() failed to lock the output"]
    #[doc = " buffer. This happens when the client makes a non blocking lock call to"]
    #[doc = " access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag."]
    #[doc = " This is not a fatal error and client should retry the same operation after"]
    #[doc = " few milliseconds."]
    NV_ENC_ERR_LOCK_BUSY = 13,
    #[doc = " This indicates that the size of the user buffer passed by the client is"]
    #[doc = " insufficient for the requested operation."]
    NV_ENC_ERR_NOT_ENOUGH_BUFFER = 14,
    #[doc = " This indicates that an invalid struct version was used by the client."]
    NV_ENC_ERR_INVALID_VERSION = 15,
    #[doc = " This indicates that ::NvEncMapInputResource() API failed to map the client"]
    #[doc = " provided input resource."]
    NV_ENC_ERR_MAP_FAILED = 16,
    #[doc = " This indicates encode driver requires more input buffers to produce an output"]
    #[doc = " bitstream. If this error is returned from ::NvEncEncodePicture() API, this"]
    #[doc = " is not a fatal error. If the client is encoding with B frames then,"]
    #[doc = " ::NvEncEncodePicture() API might be buffering the input frame for re-ordering."]
    #[doc = ""]
    #[doc = " A client operating in synchronous mode cannot call ::NvEncLockBitstream()"]
    #[doc = " API on the output bitstream buffer if ::NvEncEncodePicture() returned the"]
    #[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT error code."]
    #[doc = " The client must continue providing input frames until encode driver returns"]
    #[doc = " ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call"]
    #[doc = " ::NvEncLockBitstream() API on the output buffers in the same order in which"]
    #[doc = " it has called ::NvEncEncodePicture()."]
    NV_ENC_ERR_NEED_MORE_INPUT = 17,
    #[doc = " This indicates that the HW encoder is busy encoding and is unable to encode"]
    #[doc = " the input. The client should call ::NvEncEncodePicture() again after few"]
    #[doc = " milliseconds."]
    NV_ENC_ERR_ENCODER_BUSY = 18,
    #[doc = " This indicates that the completion event passed in ::NvEncEncodePicture()"]
    #[doc = " API has not been registered with encoder driver using ::NvEncRegisterAsyncEvent()."]
    NV_ENC_ERR_EVENT_NOT_REGISTERD = 19,
    #[doc = " This indicates that an unknown internal error has occurred."]
    NV_ENC_ERR_GENERIC = 20,
    #[doc = " This indicates that the client is attempting to use a feature"]
    #[doc = " that is not available for the license type for the current system."]
    NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY = 21,
    #[doc = " This indicates that the client is attempting to use a feature"]
    #[doc = " that is not implemented for the current version."]
    NV_ENC_ERR_UNIMPLEMENTED = 22,
    #[doc = " This indicates that the ::NvEncRegisterResource API failed to register the resource."]
    NV_ENC_ERR_RESOURCE_REGISTER_FAILED = 23,
    #[doc = " This indicates that the client is attempting to unregister a resource"]
    #[doc = " that has not been successfully registered."]
    NV_ENC_ERR_RESOURCE_NOT_REGISTERED = 24,
    #[doc = " This indicates that the client is attempting to unmap a resource"]
    #[doc = " that has not been successfully mapped."]
    NV_ENC_ERR_RESOURCE_NOT_MAPPED = 25,
}
#[doc = " Error Codes"]
pub use self::_NVENCSTATUS as NVENCSTATUS;
#[repr(u32)]
#[doc = " Encode Picture encode flags."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_FLAGS {
    #[doc = "< Encode the current picture as an Intra picture"]
    NV_ENC_PIC_FLAG_FORCEINTRA = 1,
    #[doc = "< Encode the current picture as an IDR picture."]
    #[doc = "This flag is only valid when Picture type decision is taken by the Encoder"]
    #[doc = "[_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]."]
    NV_ENC_PIC_FLAG_FORCEIDR = 2,
    #[doc = "< Write the sequence and picture header in encoded bitstream of the current picture"]
    NV_ENC_PIC_FLAG_OUTPUT_SPSPPS = 4,
    #[doc = "< Indicates end of the input stream"]
    NV_ENC_PIC_FLAG_EOS = 8,
}
#[doc = " Encode Picture encode flags."]
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
#[repr(u32)]
#[doc = " Memory heap to allocate input and output buffers."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MEMORY_HEAP {
    #[doc = "< Memory heap to be decided by the encoder driver based on the usage"]
    NV_ENC_MEMORY_HEAP_AUTOSELECT = 0,
    #[doc = "< Memory heap is in local video memory"]
    NV_ENC_MEMORY_HEAP_VID = 1,
    #[doc = "< Memory heap is in cached system memory"]
    NV_ENC_MEMORY_HEAP_SYSMEM_CACHED = 2,
    #[doc = "< Memory heap is in uncached system memory"]
    NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED = 3,
}
#[doc = " Memory heap to allocate input and output buffers."]
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
#[repr(u32)]
#[doc = " B-frame used as reference modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BFRAME_REF_MODE {
    #[doc = "< B frame is not used for reference"]
    NV_ENC_BFRAME_REF_MODE_DISABLED = 0,
    #[doc = "< Each B-frame will be used for reference. currently not supported for H.264"]
    NV_ENC_BFRAME_REF_MODE_EACH = 1,
    #[doc = "< Only(Number of B-frame)/2 th B-frame will be used for reference"]
    NV_ENC_BFRAME_REF_MODE_MIDDLE = 2,
}
#[doc = " B-frame used as reference modes"]
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
#[repr(u32)]
#[doc = " H.264 entropy coding modes."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ENTROPY_CODING_MODE {
    #[doc = "< Entropy coding mode is auto selected by the encoder driver"]
    NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT = 0,
    #[doc = "< Entropy coding mode is CABAC"]
    NV_ENC_H264_ENTROPY_CODING_MODE_CABAC = 1,
    #[doc = "< Entropy coding mode is CAVLC"]
    NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC = 2,
}
#[doc = " H.264 entropy coding modes."]
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
#[repr(u32)]
#[doc = " H.264 specific BDirect modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_BDIRECT_MODE {
    #[doc = "< BDirect mode is auto selected by the encoder driver"]
    NV_ENC_H264_BDIRECT_MODE_AUTOSELECT = 0,
    #[doc = "< Disable BDirect mode"]
    NV_ENC_H264_BDIRECT_MODE_DISABLE = 1,
    #[doc = "< Temporal BDirect mode"]
    NV_ENC_H264_BDIRECT_MODE_TEMPORAL = 2,
    #[doc = "< Spatial BDirect mode"]
    NV_ENC_H264_BDIRECT_MODE_SPATIAL = 3,
}
#[doc = " H.264 specific BDirect modes"]
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
#[repr(u32)]
#[doc = " H.264 specific FMO usage"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_FMO_MODE {
    #[doc = "< FMO usage is auto selected by the encoder driver"]
    NV_ENC_H264_FMO_AUTOSELECT = 0,
    #[doc = "< Enable FMO"]
    NV_ENC_H264_FMO_ENABLE = 1,
    #[doc = "< Disable FMO"]
    NV_ENC_H264_FMO_DISABLE = 2,
}
#[doc = " H.264 specific FMO usage"]
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
#[repr(u32)]
#[doc = " H.264 specific Adaptive Transform modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    #[doc = "< Adaptive Transform 8x8 mode is auto selected by the encoder driver"]
    NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT = 0,
    #[doc = "< Adaptive Transform 8x8 mode disabled"]
    NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE = 1,
    #[doc = "< Adaptive Transform 8x8 mode should be used"]
    NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE = 2,
}
#[doc = " H.264 specific Adaptive Transform modes"]
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
#[repr(u32)]
#[doc = " Stereo frame packing modes."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_STEREO_PACKING_MODE {
    #[doc = "< No Stereo packing required"]
    NV_ENC_STEREO_PACKING_MODE_NONE = 0,
    #[doc = "< Checkerboard mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD = 1,
    #[doc = "< Column Interleave mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE = 2,
    #[doc = "< Row Interleave mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE = 3,
    #[doc = "< Side-by-side mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE = 4,
    #[doc = "< Top-Bottom mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM = 5,
    #[doc = "< Frame Sequential mode for packing stereo frames"]
    NV_ENC_STEREO_PACKING_MODE_FRAMESEQ = 6,
}
#[doc = " Stereo frame packing modes."]
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
#[repr(u32)]
#[doc = "  Input Resource type"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_INPUT_RESOURCE_TYPE {
    #[doc = "< input resource type is a directx9 surface"]
    NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX = 0,
    #[doc = "< input resource type is a cuda device pointer surface"]
    NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR = 1,
    #[doc = "< input resource type is a cuda array surface."]
    #[doc = "This array must be a 2D array and the CUDA_ARRAY3D_SURFACE_LDST"]
    #[doc = "flag must have been specified when creating it."]
    NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY = 2,
    #[doc = "< input resource type is an OpenGL texture"]
    NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX = 3,
}
#[doc = "  Input Resource type"]
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
#[repr(u32)]
#[doc = "  Buffer usage"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_USAGE {
    #[doc = "< Registered surface will be used for input image"]
    NV_ENC_INPUT_IMAGE = 0,
    #[doc = "< Registered surface will be used for output of H.264 ME only mode."]
    #[doc = "This buffer usage type is not supported for HEVC ME only mode."]
    NV_ENC_OUTPUT_MOTION_VECTOR = 1,
    #[doc = "< Registered surface will be used for output bitstream in encoding"]
    NV_ENC_OUTPUT_BITSTREAM = 2,
}
#[doc = "  Buffer usage"]
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
#[repr(u32)]
#[doc = "  Encoder Device type"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_DEVICE_TYPE {
    #[doc = "< encode device type is a directx9 device"]
    NV_ENC_DEVICE_TYPE_DIRECTX = 0,
    #[doc = "< encode device type is a cuda device"]
    NV_ENC_DEVICE_TYPE_CUDA = 1,
    #[doc = "< encode device type is an OpenGL device."]
    #[doc = "Use of this device type is supported only on Linux"]
    NV_ENC_DEVICE_TYPE_OPENGL = 2,
}
#[doc = "  Encoder Device type"]
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
#[repr(u32)]
#[doc = " Number of reference frames"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_NUM_REF_FRAMES {
    #[doc = "< Number of reference frames is auto selected by the encoder driver"]
    NV_ENC_NUM_REF_FRAMES_AUTOSELECT = 0,
    #[doc = "< Number of reference frames equal to 1"]
    NV_ENC_NUM_REF_FRAMES_1 = 1,
    #[doc = "< Number of reference frames equal to 2"]
    NV_ENC_NUM_REF_FRAMES_2 = 2,
    #[doc = "< Number of reference frames equal to 3"]
    NV_ENC_NUM_REF_FRAMES_3 = 3,
    #[doc = "< Number of reference frames equal to 4"]
    NV_ENC_NUM_REF_FRAMES_4 = 4,
    #[doc = "< Number of reference frames equal to 5"]
    NV_ENC_NUM_REF_FRAMES_5 = 5,
    #[doc = "< Number of reference frames equal to 6"]
    NV_ENC_NUM_REF_FRAMES_6 = 6,
    #[doc = "< Number of reference frames equal to 7"]
    NV_ENC_NUM_REF_FRAMES_7 = 7,
}
#[doc = " Number of reference frames"]
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
#[repr(u32)]
#[doc = " Encoder capabilities enumeration."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_CAPS {
    #[doc = " Maximum number of B-Frames supported."]
    NV_ENC_CAPS_NUM_MAX_BFRAMES = 0,
    #[doc = " Rate control modes supported."]
    #[doc = " \\n The API return value is a bitmask of the values in NV_ENC_PARAMS_RC_MODE."]
    NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES = 1,
    #[doc = " Indicates HW support for field mode encoding."]
    #[doc = " \\n 0 : Interlaced mode encoding is not supported."]
    #[doc = " \\n 1 : Interlaced field mode encoding is supported."]
    #[doc = " \\n 2 : Interlaced frame encoding and field mode encoding are both supported."]
    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING = 2,
    #[doc = " Indicates HW support for monochrome mode encoding."]
    #[doc = " \\n 0 : Monochrome mode not supported."]
    #[doc = " \\n 1 : Monochrome mode supported."]
    NV_ENC_CAPS_SUPPORT_MONOCHROME = 3,
    #[doc = " Indicates HW support for FMO."]
    #[doc = " \\n 0 : FMO not supported."]
    #[doc = " \\n 1 : FMO supported."]
    NV_ENC_CAPS_SUPPORT_FMO = 4,
    #[doc = " Indicates HW capability for Quarter pel motion estimation."]
    #[doc = " \\n 0 : Quarter-Pel Motion Estimation not supported."]
    #[doc = " \\n 1 : Quarter-Pel Motion Estimation supported."]
    NV_ENC_CAPS_SUPPORT_QPELMV = 5,
    #[doc = " H.264 specific. Indicates HW support for BDirect modes."]
    #[doc = " \\n 0 : BDirect mode encoding not supported."]
    #[doc = " \\n 1 : BDirect mode encoding supported."]
    NV_ENC_CAPS_SUPPORT_BDIRECT_MODE = 6,
    #[doc = " H264 specific. Indicates HW support for CABAC entropy coding mode."]
    #[doc = " \\n 0 : CABAC entropy coding not supported."]
    #[doc = " \\n 1 : CABAC entropy coding supported."]
    NV_ENC_CAPS_SUPPORT_CABAC = 7,
    #[doc = " Indicates HW support for Adaptive Transform."]
    #[doc = " \\n 0 : Adaptive Transform not supported."]
    #[doc = " \\n 1 : Adaptive Transform supported."]
    NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM = 8,
    #[doc = " Indicates HW support for Multi View Coding."]
    #[doc = " \\n 0 : Multi View Coding not supported."]
    #[doc = " \\n 1 : Multi View Coding supported."]
    NV_ENC_CAPS_SUPPORT_STEREO_MVC = 9,
    #[doc = " Indicates HW support for encoding Temporal layers."]
    #[doc = " \\n 0 : Encoding Temporal layers not supported."]
    #[doc = " \\n 1 : Encoding Temporal layers supported."]
    NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS = 10,
    #[doc = " Indicates HW support for Hierarchical P frames."]
    #[doc = " \\n 0 : Hierarchical P frames not supported."]
    #[doc = " \\n 1 : Hierarchical P frames supported."]
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES = 11,
    #[doc = " Indicates HW support for Hierarchical B frames."]
    #[doc = " \\n 0 : Hierarchical B frames not supported."]
    #[doc = " \\n 1 : Hierarchical B frames supported."]
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES = 12,
    #[doc = " Maximum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
    NV_ENC_CAPS_LEVEL_MAX = 13,
    #[doc = " Minimum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
    NV_ENC_CAPS_LEVEL_MIN = 14,
    #[doc = " Indicates HW support for separate colour plane encoding."]
    #[doc = " \\n 0 : Separate colour plane encoding not supported."]
    #[doc = " \\n 1 : Separate colour plane encoding supported."]
    NV_ENC_CAPS_SEPARATE_COLOUR_PLANE = 15,
    #[doc = " Maximum output width supported."]
    NV_ENC_CAPS_WIDTH_MAX = 16,
    #[doc = " Maximum output height supported."]
    NV_ENC_CAPS_HEIGHT_MAX = 17,
    #[doc = " Indicates Temporal Scalability Support."]
    #[doc = " \\n 0 : Temporal SVC encoding not supported."]
    #[doc = " \\n 1 : Temporal SVC encoding supported."]
    NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC = 18,
    #[doc = " Indicates Dynamic Encode Resolution Change Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Encode Resolution Change not supported."]
    #[doc = " \\n 1 : Dynamic Encode Resolution Change supported."]
    NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE = 19,
    #[doc = " Indicates Dynamic Encode Bitrate Change Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Encode bitrate change not supported."]
    #[doc = " \\n 1 : Dynamic Encode bitrate change supported."]
    NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE = 20,
    #[doc = " Indicates Forcing Constant QP On The Fly Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Forcing constant QP on the fly not supported."]
    #[doc = " \\n 1 : Forcing constant QP on the fly supported."]
    NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP = 21,
    #[doc = " Indicates Dynamic rate control mode Change Support."]
    #[doc = " \\n 0 : Dynamic rate control mode change not supported."]
    #[doc = " \\n 1 : Dynamic rate control mode change supported."]
    NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE = 22,
    #[doc = " Indicates Subframe readback support for slice-based encoding. If this feature is supported, it can be enabled by setting enableSubFrameWrite = 1."]
    #[doc = " \\n 0 : Subframe readback not supported."]
    #[doc = " \\n 1 : Subframe readback supported."]
    NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK = 23,
    #[doc = " Indicates Constrained Encoding mode support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Constrained encoding mode not supported."]
    #[doc = " \\n 1 : Constrained encoding mode supported."]
    #[doc = " If this mode is supported client can enable this during initialization."]
    #[doc = " Client can then force a picture to be coded as constrained picture where"]
    #[doc = " in-loop filtering is disabled across slice boundaries and prediction vectors for inter"]
    #[doc = " macroblocks in each slice will be restricted to the slice region."]
    NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING = 24,
    #[doc = " Indicates Intra Refresh Mode Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Intra Refresh Mode not supported."]
    #[doc = " \\n 1 : Intra Refresh Mode supported."]
    NV_ENC_CAPS_SUPPORT_INTRA_REFRESH = 25,
    #[doc = " Indicates Custom VBV Buffer Size support. It can be used for capping frame size."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Custom VBV buffer size specification from client, not supported."]
    #[doc = " \\n 1 : Custom VBV buffer size specification from client, supported."]
    NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE = 26,
    #[doc = " Indicates Dynamic Slice Mode Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Dynamic Slice Mode not supported."]
    #[doc = " \\n 1 : Dynamic Slice Mode supported."]
    NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE = 27,
    #[doc = " Indicates Reference Picture Invalidation Support."]
    #[doc = " Support added from NvEncodeAPI version 2.0."]
    #[doc = " \\n 0 : Reference Picture Invalidation not supported."]
    #[doc = " \\n 1 : Reference Picture Invalidation supported."]
    NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION = 28,
    #[doc = " Indicates support for Pre-Processing."]
    #[doc = " The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS"]
    NV_ENC_CAPS_PREPROC_SUPPORT = 29,
    #[doc = " Indicates support Async mode."]
    #[doc = " \\n 0 : Async Encode mode not supported."]
    #[doc = " \\n 1 : Async Encode mode supported."]
    NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT = 30,
    #[doc = " Maximum MBs per frame supported."]
    NV_ENC_CAPS_MB_NUM_MAX = 31,
    #[doc = " Maximum aggregate throughput in MBs per sec."]
    NV_ENC_CAPS_MB_PER_SEC_MAX = 32,
    #[doc = " Indicates HW support for YUV444 mode encoding."]
    #[doc = " \\n 0 : YUV444 mode encoding not supported."]
    #[doc = " \\n 1 : YUV444 mode encoding supported."]
    NV_ENC_CAPS_SUPPORT_YUV444_ENCODE = 33,
    #[doc = " Indicates HW support for lossless encoding."]
    #[doc = " \\n 0 : lossless encoding not supported."]
    #[doc = " \\n 1 : lossless encoding supported."]
    NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE = 34,
    #[doc = " Indicates HW support for Sample Adaptive Offset."]
    #[doc = " \\n 0 : SAO not supported."]
    #[doc = " \\n 1 : SAO encoding supported."]
    NV_ENC_CAPS_SUPPORT_SAO = 35,
    #[doc = " Indicates HW support for Motion Estimation Only Mode."]
    #[doc = " \\n 0 : MEOnly Mode not supported."]
    #[doc = " \\n 1 : MEOnly Mode supported for I and P frames."]
    #[doc = " \\n 2 : MEOnly Mode supported for I, P and B frames."]
    NV_ENC_CAPS_SUPPORT_MEONLY_MODE = 36,
    #[doc = " Indicates HW support for lookahead encoding (enableLookahead=1)."]
    #[doc = " \\n 0 : Lookahead not supported."]
    #[doc = " \\n 1 : Lookahead supported."]
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD = 37,
    #[doc = " Indicates HW support for temporal AQ encoding (enableTemporalAQ=1)."]
    #[doc = " \\n 0 : Temporal AQ not supported."]
    #[doc = " \\n 1 : Temporal AQ supported."]
    NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ = 38,
    #[doc = " Indicates HW support for 10 bit encoding."]
    #[doc = " \\n 0 : 10 bit encoding not supported."]
    #[doc = " \\n 1 : 10 bit encoding supported."]
    NV_ENC_CAPS_SUPPORT_10BIT_ENCODE = 39,
    #[doc = " Maximum number of Long Term Reference frames supported"]
    NV_ENC_CAPS_NUM_MAX_LTR_FRAMES = 40,
    #[doc = " Indicates HW support for Weighted Prediction."]
    #[doc = " \\n 0 : Weighted Prediction not supported."]
    #[doc = " \\n 1 : Weighted Prediction supported."]
    NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION = 41,
    #[doc = " On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used"]
    #[doc = " to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity."]
    #[doc = " This API can be called at any time; i.e. during the encode session or before opening the encode session."]
    #[doc = " If the available encoder capacity is returned as zero, applications may choose to switch to software encoding"]
    #[doc = " and continue to call this API (e.g. polling once per second) until capacity becomes available."]
    #[doc = ""]
    #[doc = " On bare metal (non-virtualized GPU) and linux platforms, this API always returns 100."]
    NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY = 42,
    #[doc = " Indicates B as reference support."]
    #[doc = " \\n 0 : B as reference is not supported."]
    #[doc = " \\n 1 : each B-Frame as reference is supported."]
    #[doc = " \\n 2 : only Middle B-frame as reference is supported."]
    NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE = 43,
    #[doc = " Indicates HW support for Emphasis Level Map based delta QP computation."]
    #[doc = " \\n 0 : Emphasis Level Map based delta QP not supported."]
    #[doc = " \\n 1 : Emphasis Level Map based delta QP is supported."]
    NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP = 44,
    #[doc = " Minimum input width supported."]
    NV_ENC_CAPS_WIDTH_MIN = 45,
    #[doc = " Minimum input height supported."]
    NV_ENC_CAPS_HEIGHT_MIN = 46,
    #[doc = " Indicates HW support for multiple reference frames."]
    NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES = 47,
    #[doc = " Indicates HW support for HEVC with alpha encoding."]
    #[doc = " \\n 0 : HEVC with alpha encoding not supported."]
    #[doc = " \\n 1 : HEVC with alpha encoding is supported."]
    NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING = 48,
    #[doc = " Indicates number of Encoding engines present on GPU."]
    NV_ENC_CAPS_NUM_ENCODER_ENGINES = 49,
    #[doc = " Indicates single slice intra refresh support."]
    NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH = 50,
    #[doc = " Reserved - Not to be used by clients."]
    NV_ENC_CAPS_EXPOSED_COUNT = 51,
}
#[doc = " Encoder capabilities enumeration."]
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
#[repr(u32)]
#[doc = "  HEVC CU SIZE"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_HEVC_CUSIZE {
    NV_ENC_HEVC_CUSIZE_AUTOSELECT = 0,
    NV_ENC_HEVC_CUSIZE_8x8 = 1,
    NV_ENC_HEVC_CUSIZE_16x16 = 2,
    NV_ENC_HEVC_CUSIZE_32x32 = 3,
    NV_ENC_HEVC_CUSIZE_64x64 = 4,
}
#[doc = "  HEVC CU SIZE"]
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
#[doc = " Input struct for querying Encoding capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CAPS_PARAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CAPS_PARAM_VER"]
    pub version: u32,
    #[doc = "< [in]: Specifies the encode capability to be queried. Client should pass a member for ::NV_ENC_CAPS enum."]
    pub capsToQuery: NV_ENC_CAPS,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CAPS_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CAPS_PARAM>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CAPS_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).capsToQuery as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(capsToQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _NV_ENC_CAPS_PARAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Input struct for querying Encoding capabilities."]
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[doc = " Encoder Output parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    #[doc = "< [out]: Struct version."]
    pub version: u32,
    #[doc = "< [out]: Encoded bitstream size in bytes"]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_ENCODE_OUT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).bitstreamSizeInBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_ENCODE_OUT_PARAMS>())).reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _NV_ENC_ENCODE_OUT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder Output parameters"]
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
#[doc = " Creation parameters for input buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_INPUT_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Input frame width"]
    pub width: u32,
    #[doc = "< [in]: Input frame height"]
    pub height: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Input buffer format"]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to input buffer"]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Pointer to existing system memory buffer"]
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 57usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).memoryHeap as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).bufferFmt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).pSysMemBuffer as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(pSysMemBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Creation parameters for input buffer."]
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[doc = " Creation parameters for output bitstream buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_BITSTREAM_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub size: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to the output bitstream buffer"]
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Reserved and should not be used"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 58usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_BITSTREAM_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).memoryHeap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBufferPtr
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved1 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved2 as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CREATE_BITSTREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Creation parameters for output bitstream buffer."]
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[doc = " Structs needed for ME only mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    #[doc = "< the x component of MV in quarter-pel units"]
    pub mvx: i16,
    #[doc = "< the y component of MV in quarter-pel units"]
    pub mvy: i16,
}
#[test]
fn bindgen_test_layout__NV_ENC_MVECTOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MVECTOR>(),
        4usize,
        concat!("Size of: ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MVECTOR>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MVECTOR>())).mvx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MVECTOR>())).mvy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvy)
        )
    );
}
#[doc = " Structs needed for ME only mode."]
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    #[doc = "< up to 4 vectors for 8x8 partition"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1 (P), 2 (IPCM), 3 (B)"]
    pub mbType: u8,
    #[doc = "< Specifies the block partition type. 0:16x16, 1:8x8, 2:16x8, 3:8x16"]
    pub partitionType: u8,
    #[doc = "< reserved padding for alignment"]
    pub reserved: u16,
    pub mbCost: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_H264_MV_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_H264_MV_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_H264_MV_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mbType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).partitionType as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(partitionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).reserved as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_H264_MV_DATA>())).mbCost as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbCost)
        )
    );
}
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    #[doc = "< up to 4 vectors within a CU"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1(P)"]
    pub cuType: u8,
    #[doc = "< 0: 8x8, 1: 16x16, 2: 32x32, 3: 64x64"]
    pub cuSize: u8,
    #[doc = "< The CU partition mode"]
    #[doc = "0 (2Nx2N), 1 (2NxN), 2(Nx2N), 3 (NxN),"]
    #[doc = "4 (2NxnU), 5 (2NxnD), 6(nLx2N), 7 (nRx2N)"]
    pub partitionMode: u8,
    #[doc = "< Marker to separate CUs in the current CTB from CUs in the next CTB"]
    pub lastCUInCTB: u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_HEVC_MV_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_HEVC_MV_DATA>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_HEVC_MV_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).mv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).cuType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).cuSize as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).partitionMode as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(partitionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_HEVC_MV_DATA>())).lastCUInCTB as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(lastCUInCTB)
        )
    );
}
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [out]: Pointer to the output motion vector buffer"]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_MV_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).mvBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CREATE_MV_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[doc = " QP value for frames"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    #[doc = "< [in]: Specifies QP value for P-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterP: u32,
    #[doc = "< [in]: Specifies QP value for B-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterB: u32,
    #[doc = "< [in]: Specifies QP value for Intra Frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpIntra: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_QP() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_QP>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_QP>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpIntra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpIntra)
        )
    );
}
#[doc = " QP value for frames"]
pub type NV_ENC_QP = _NV_ENC_QP;
#[doc = " Rate Control Configuration Parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    #[doc = "< [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps."]
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    #[doc = "< [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode."]
    pub constQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the average bitrate(in bits/sec) used for encoding."]
    pub averageBitRate: u32,
    #[doc = "< [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode."]
    pub maxBitRate: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size."]
    pub vbvBufferSize: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay ."]
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1."]
    pub minQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1."]
    pub maxQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1."]
    pub initialRCQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the temporal layers (as a bitmask) whose QPs have changed. Valid max bitmask is [2^NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS - 1]."]
    #[doc = "Applicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporallayerIdxMask: u32,
    #[doc = "< [in]: Specifies the temporal layer QPs used for rate control. Temporal layer index is used as the array index."]
    #[doc = "Applicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporalLayerQP: [u8; 8usize],
    #[doc = "< [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)"]
    pub targetQuality: u8,
    #[doc = "< [in]: Fractional part of target quality (as 8.8 fixed point format)"]
    pub targetQualityLSB: u8,
    #[doc = "< [in]: Maximum depth of lookahead with range 0-(31 - number of B frames)."]
    #[doc = "lookaheadDepth is only used if enableLookahead=1."]
    pub lookaheadDepth: u16,
    #[doc = "< [in]: Specifies the ratio of I frame bits to P frame bits in case of single frame VBV and CBR rate control mode,"]
    #[doc = "is set to 2 by default for low latency tuning info and 1 by default for ultra low latency tuning info"]
    pub lowDelayKeyFrameScale: u8,
    pub reserved1: [u8; 3usize],
    #[doc = "< [in]: This flag is used to interpret values in array specified by NV_ENC_PIC_PARAMS::qpDeltaMap."]
    #[doc = "Set this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map."]
    #[doc = "Emphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL."]
    #[doc = "Emphasis Level Map is used to specify regions to be encoded at varying levels of quality."]
    #[doc = "The hardware encoder adjusts the quantization within the image as per the provided emphasis map,"]
    #[doc = "by adjusting the quantization parameter (QP) assigned to each macroblock. This adjustment is commonly called “Delta QP”."]
    #[doc = "The adjustment depends on the absolute QP decided by the rate control algorithm, and is applied after the rate control has decided each macroblock’s QP."]
    #[doc = "Since the Delta QP overrides rate control, enabling Emphasis Level Map may violate bitrate and VBV buffer size constraints."]
    #[doc = "Emphasis Level Map is useful in situations where client has a priori knowledge of the image complexity (e.g. via use of NVFBC's Classification feature) and encoding those high-complexity areas at higher quality (lower QP) is important, even at the possible cost of violating bitrate/VBV buffer size constraints"]
    #[doc = "This feature is not supported when AQ( Spatial/Temporal) is enabled."]
    #[doc = "This feature is only supported for H264 codec currently."]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QP Delta. This specifies QP modifier to be applied on top of the QP chosen by rate control"]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DISABLED to ignore NV_ENC_PIC_PARAMS::qpDeltaMap values. In this case, qpDeltaMap should be set to NULL."]
    #[doc = ""]
    #[doc = "Other values are reserved for future use."]
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    #[doc = "< [in]: This flag is used to enable multi-pass encoding for a given ::NV_ENC_PARAMS_RC_MODE. This flag is not valid for H264 and HEVC MEOnly mode"]
    pub multiPass: NV_ENC_MULTI_PASS,
    #[doc = "< [in]: Specifies the ratio in which bitrate should be split between base and alpha layer. A value 'x' for this field will split the target bitrate in a ratio of x : 1 between base and alpha layer."]
    #[doc = "The default split ratio is 15."]
    pub alphaLayerBitrateRatio: u32,
    #[doc = "< [in]: Specifies the value of 'chroma_qp_index_offset' in H264 / 'pps_cb_qp_offset' in HEVC."]
    pub cbQPIndexOffset: i8,
    #[doc = "< [in]: Specifies the value of 'second_chroma_qp_index_offset' in H264 / 'pps_cr_qp_offset' in HEVC."]
    pub crQPIndexOffset: i8,
    pub reserved2: u16,
    pub reserved: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_RC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RC_PARAMS>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).rateControlMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(rateControlMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).constQP as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(constQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).averageBitRate as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(averageBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxBitRate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvBufferSize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvInitialDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvInitialDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).minQP as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(minQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxQP as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).initialRCQP as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(initialRCQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporallayerIdxMask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporallayerIdxMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporalLayerQP as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporalLayerQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQuality as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQualityLSB as *const _ as usize
        },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQualityLSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).lookaheadDepth as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lookaheadDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).lowDelayKeyFrameScale as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lowDelayKeyFrameScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved1 as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).qpMapMode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(qpMapMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).multiPass as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(multiPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).alphaLayerBitrateRatio as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(alphaLayerBitrateRatio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).cbQPIndexOffset as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(cbQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).crQPIndexOffset as *const _ as usize
        },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(crQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved2 as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _NV_ENC_RC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Rate Control Configuration Parameters"]
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    #[doc = "< [in]: if set to 1 , it specifies that the overscanInfo is present"]
    pub overscanInfoPresentFlag: u32,
    #[doc = "< [in]: Specifies the overscan info(as defined in Annex E of the ITU-T Specification)."]
    pub overscanInfo: u32,
    #[doc = "< [in]: If set to 1, it specifies  that the videoFormat, videoFullRangeFlag and colourDescriptionPresentFlag are present."]
    pub videoSignalTypePresentFlag: u32,
    #[doc = "< [in]: Specifies the source video format(as defined in Annex E of the ITU-T Specification)."]
    pub videoFormat: u32,
    #[doc = "< [in]: Specifies the output range of the luma and chroma samples(as defined in Annex E of the ITU-T Specification)."]
    pub videoFullRangeFlag: u32,
    #[doc = "< [in]: If set to 1, it specifies that the colourPrimaries, transferCharacteristics and colourMatrix are present."]
    pub colourDescriptionPresentFlag: u32,
    #[doc = "< [in]: Specifies color primaries for converting to RGB(as defined in Annex E of the ITU-T Specification)"]
    pub colourPrimaries: u32,
    #[doc = "< [in]: Specifies the opto-electronic transfer characteristics to use (as defined in Annex E of the ITU-T Specification)"]
    pub transferCharacteristics: u32,
    #[doc = "< [in]: Specifies the matrix coefficients used in deriving the luma and chroma from the RGB primaries (as defined in Annex E of the ITU-T Specification)."]
    pub colourMatrix: u32,
    #[doc = "< [in]: if set to 1 , it specifies that the chromaSampleLocationTop and chromaSampleLocationBot are present."]
    pub chromaSampleLocationFlag: u32,
    #[doc = "< [in]: Specifies the chroma sample location for top field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationTop: u32,
    #[doc = "< [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationBot: u32,
    #[doc = "< [in]: if set to 1, it specifies the bitstream restriction parameters are present in the bitstream."]
    pub bitstreamRestrictionFlag: u32,
    pub reserved: [u32; 15usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_VUI_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        112usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfoPresentFlag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .videoSignalTypePresentFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoSignalTypePresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFormat as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFullRangeFlag
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFullRangeFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .colourDescriptionPresentFlag as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourDescriptionPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourPrimaries
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).transferCharacteristics
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourMatrix as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationFlag
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationTop
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationTop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationBot
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationBot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).bitstreamRestrictionFlag
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(bitstreamRestrictionFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).reserved as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved for future use."]
    pub reserved1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE),
            "::",
            stringify!(reserved1)
        )
    );
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure for H264 and HEVC."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure for H264 and HEVC."]
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level."]
    pub level: u32,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Set to 1 to enable 4:4:4 separate colour planes"]
    pub separateColourPlaneFlag: u32,
    #[doc = "< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]. This flag corresponds"]
    #[doc = "to the flag disable_deblocking_filter_idc specified in section 7.4.3 of H.264 specification,"]
    #[doc = "which specifies whether the operation of the deblocking filter shall be disabled across some"]
    #[doc = "block edges of the slice and specifies for which edges the filtering is disabled. See section"]
    #[doc = "7.4.3 of H.264 specification for more details."]
    pub disableDeblockingFilterIDC: u32,
    #[doc = "< [in]: Specifies number of temporal layers to be used for hierarchical coding / temporal SVC. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS]"]
    pub numTemporalLayers: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: Specifies the AdaptiveTransform Mode. Check support for AdaptiveTransform mode using ::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM caps."]
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    #[doc = "< [in]: Specified the FMO Mode. Check support for FMO using ::NV_ENC_CAPS_SUPPORT_FMO caps."]
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    #[doc = "< [in]: Specifies the BDirect mode. Check support for BDirect mode using ::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE caps."]
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    #[doc = "< [in]: Specifies the entropy coding mode. Check support for CABAC mode using ::NV_ENC_CAPS_SUPPORT_CABAC caps."]
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    #[doc = "< [in]: Specifies the stereo frame packing mode which is to be signaled in frame packing arrangement SEI"]
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default DPB size."]
    #[doc = "The low latency application which wants to invalidate reference frame as an error resilience tool"]
    #[doc = "is recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent"]
    #[doc = "frames are invalidated."]
    pub maxNumRefFrames: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3 numSlices in Picture."]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the H264 video usability info parameters"]
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the number of LTR frames. This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_H264::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input."]
    #[doc = "Check support for YUV444 encoding using ::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE caps."]
    pub chromaFormatIDC: u32,
    #[doc = "< [in]: Specifies the maximum temporal layer used for temporal SVC / hierarchical coding."]
    #[doc = "Defaut value of this field is NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS. Note that the value NV_ENC_CONFIG_H264::maxNumRefFrames should"]
    #[doc = "be greater than or equal to (NV_ENC_CONFIG_H264::maxTemporalLayers - 2) * 2, for NV_ENC_CONFIG_H264::maxTemporalLayers >= 2."]
    pub maxTemporalLayers: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 267usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).idrPeriod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).separateColourPlaneFlag as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(separateColourPlaneFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).disableDeblockingFilterIDC as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(disableDeblockingFilterIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numTemporalLayers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).spsId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ppsId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).adaptiveTransformMode as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(adaptiveTransformMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).fmoMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(fmoMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).bdirectMode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(bdirectMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).entropyCodingMode as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(entropyCodingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).stereoMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(stereoMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshPeriod as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshCnt as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxNumRefFrames as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxNumRefFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceMode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceModeData as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).h264VUIParameters as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(h264VUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrNumFrames as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrTrustMode as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).chromaFormatIDC as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(chromaFormatIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxTemporalLayers as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxTemporalLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).useBFramesAsRef as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL0 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved1 as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved2 as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CONFIG_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        singleSliceIntraRefresh: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::std::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::std::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC {
    #[doc = "< [in]: Specifies the level of the encoded bitstream."]
    pub level: u32,
    #[doc = "< [in]: Specifies the level tier of the encoded bitstream."]
    pub tier: u32,
    #[doc = "< [in]: Specifies the minimum size of luma coding unit."]
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    #[doc = "< [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32."]
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG. Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the maximum number of references frames in the DPB."]
    pub maxNumRefFramesInDPB: u32,
    #[doc = "< [in]: This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the VPS id of the video parameter set"]
    pub vpsId: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayersMinus1: u32,
    #[doc = "< [in]: Specifies the HEVC video usability info parameters"]
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_HEVC::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 214usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC>(),
        1560usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).tier as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).minCUSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(minCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxCUSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).idrPeriod as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshPeriod as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshCnt as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxNumRefFramesInDPB as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrNumFrames as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).vpsId as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(vpsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).spsId as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ppsId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceMode as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceModeData as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxTemporalLayersMinus1 as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).hevcVUIParameters as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(hevcVUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrTrustMode as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).useBFramesAsRef as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL0 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL1 as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved2 as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CONFIG_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        singleSliceIntraRefresh: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::std::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved2 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CONFIG_H264_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 256usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved1 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
}
impl Default for _NV_ENC_CONFIG_HEVC_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    #[doc = "< [in]: Specifies the H.264-specific encoder configuration."]
    pub h264Config: NV_ENC_CONFIG_H264,
    #[doc = "< [in]: Specifies the HEVC-specific encoder configuration."]
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    #[doc = "< [in]: Specifies the H.264-specific ME only encoder configuration."]
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    #[doc = "< [in]: Specifies the HEVC-specific ME only encoder configuration."]
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 320usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_CONFIG>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264Config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264Config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcConfig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264MeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264MeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcMeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcMeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _NV_ENC_CODEC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the codec profile GUID. If client specifies \\p NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID the NvEncodeAPI interface will select the appropriate codec profile."]
    pub profileGUID: GUID,
    #[doc = "< [in]: Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically."]
    pub gopLength: u32,
    #[doc = "< [in]: Specifies the GOP pattern as follows: \\p frameIntervalP = 0: I, 1: IPP, 2: IBP, 3: IBBP  If goplength is set to NVENC_INFINITE_GOPLENGTH \\p frameIntervalP should be set to 1."]
    pub frameIntervalP: i32,
    #[doc = "< [in]: Set this to 1 to enable monochrome encoding for this session."]
    pub monoChromeEncoding: u32,
    #[doc = "< [in]: Specifies the frame/field mode."]
    #[doc = "Check support for field encoding using ::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING caps."]
    #[doc = "Using a frameFieldMode other than NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME for RGB input is not supported."]
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    #[doc = "< [in]: Specifies the desired motion vector prediction precision."]
    pub mvPrecision: NV_ENC_MV_PRECISION,
    #[doc = "< [in]: Specifies the rate control parameters for the current encoding session."]
    pub rcParams: NV_ENC_RC_PARAMS,
    #[doc = "< [in]: Specifies the codec specific config parameters through this union."]
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 278usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG>(),
        3584usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).profileGUID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(profileGUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).gopLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(gopLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameIntervalP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameIntervalP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).monoChromeEncoding as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(monoChromeEncoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameFieldMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameFieldMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).mvPrecision as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(mvPrecision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).rcParams as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(rcParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).encodeCodecConfig as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(encodeCodecConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved as *const _ as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved2 as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
#[repr(u32)]
#[doc = "  Tuning information of NVENC encoding (TuningInfo is not applicable to H264 and HEVC MEOnly mode)."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum NV_ENC_TUNING_INFO {
    #[doc = "< Undefined tuningInfo. Invalid value for encoding."]
    NV_ENC_TUNING_INFO_UNDEFINED = 0,
    #[doc = "< Tune presets for latency tolerant encoding."]
    NV_ENC_TUNING_INFO_HIGH_QUALITY = 1,
    #[doc = "< Tune presets for low latency streaming."]
    NV_ENC_TUNING_INFO_LOW_LATENCY = 2,
    #[doc = "< Tune presets for ultra low latency streaming."]
    NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY = 3,
    #[doc = "< Tune presets for lossless encoding."]
    NV_ENC_TUNING_INFO_LOSSLESS = 4,
    #[doc = "< Count number of tuningInfos. Invalid value."]
    NV_ENC_TUNING_INFO_COUNT = 5,
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the Encode GUID for which the encoder is being created. ::NvEncInitializeEncoder() API will fail if this is not set, or set to unsupported value."]
    pub encodeGUID: GUID,
    #[doc = "< [in]: Specifies the preset for encoding. If the preset GUID is set then , the preset configuration will be applied before any other parameter."]
    pub presetGUID: GUID,
    #[doc = "< [in]: Specifies the encode width. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeWidth: u32,
    #[doc = "< [in]: Specifies the encode height. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeHeight: u32,
    #[doc = "< [in]: Specifies the display aspect ratio Width."]
    pub darWidth: u32,
    #[doc = "< [in]: Specifies the display aspect ratio height."]
    pub darHeight: u32,
    #[doc = "< [in]: Specifies the numerator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateNum: u32,
    #[doc = "< [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateDen: u32,
    #[doc = "< [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification."]
    pub enableEncodeAsync: u32,
    #[doc = "< [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface."]
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved private data buffer size and must be set to 0"]
    pub privDataSize: u32,
    #[doc = "< [in]: Reserved private data buffer and must be set to NULL"]
    pub privData: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters."]
    #[doc = "Client can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS."]
    #[doc = "Even in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API."]
    pub encodeConfig: *mut NV_ENC_CONFIG,
    #[doc = "< [in]: Maximum encode width to be used for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encoder will not allow dynamic resolution change."]
    pub maxEncodeWidth: u32,
    #[doc = "< [in]: Maximum encode height to be allowed for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encode will not allow dynamic resolution change."]
    pub maxEncodeHeight: u32,
    #[doc = "< [in]: If Client wants to pass external motion vectors in NV_ENC_PIC_PARAMS::meExternalHints buffer it must specify the maximum number of hint candidates per block per direction for the encode session."]
    #[doc = "The NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[0] is for L0 predictors and NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "This client must also set NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints to 1."]
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Tuning Info of NVENC encoding(TuningInfo is not applicable to H264 and HEVC meonly mode)."]
    pub tuningInfo: NV_ENC_TUNING_INFO,
    #[doc = "< [in]: Specifies input buffer format. Client should set input buffer format only when D3D12 interface type is used."]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 287usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INITIALIZE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        1808usize,
        concat!("Size of: ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeGUID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).presetGUID as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(presetGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeWidth as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeHeight as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darWidth as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darHeight as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateNum as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateDen as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateDen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enableEncodeAsync as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enableEncodeAsync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enablePTD as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enablePTD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privDataSize as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privData as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeConfig as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeWidth as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeHeight as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxMEHintCountsPerBlock
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxMEHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).tuningInfo as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(tuningInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).bufferFormat as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved2 as *const _ as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_INITIALIZE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        enableOutputInVidmem: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::std::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_RECONFIGURE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Encoder session re-initialization parameters."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is the same as the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will continue to use the existing encode"]
    #[doc = "configuration."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is different from the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will try to use the default configuration for"]
    #[doc = "the preset specified by reInitEncodeParams.presetGUID."]
    #[doc = "In this case, reconfiguration may fail if the new"]
    #[doc = "configuration is incompatible with the existing"]
    #[doc = "configuration (e.g. the new configuration results in"]
    #[doc = "a change in the GOP structure)."]
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_RECONFIGURE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        1824usize,
        concat!("Size of: ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).reInitEncodeParams as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(reInitEncodeParams)
        )
    );
}
impl Default for _NV_ENC_RECONFIGURE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [out]: preset config returned by the Nvidia Video Encoder interface."]
    pub presetCfg: NV_ENC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PRESET_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PRESET_CONFIG>(),
        5128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PRESET_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).presetCfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(presetCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved1 as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved2 as *const _ as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_PRESET_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_MVC_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the view ID associated with the current input view."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the temporal ID associated with the current input view."]
    pub temporalID: u32,
    #[doc = "< [in]: Specifies the priority ID associated with the current input view. Reserved and ignored by the NvEncodeAPI interface."]
    pub priorityID: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 12usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_MVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).viewID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).temporalID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(temporalID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).priorityID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(priorityID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved2 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_PIC_PARAMS_MVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    #[doc = "< [in]: Specifies the MVC picture parameters."]
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 32usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264_EXT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).mvcPicParams as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(mvcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).reserved1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(reserved1)
        )
    );
}
impl Default for _NV_ENC_PIC_PARAMS_H264_EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    #[doc = "< [in] SEI payload size in bytes. SEI payload must be byte aligned, as described in Annex D"]
    pub payloadSize: u32,
    #[doc = "< [in] SEI payload types and syntax can be found in Annex D of the H.264 Specification."]
    pub payloadType: u32,
    #[doc = "< [in] pointer to user data"]
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_SEI_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEI_PAYLOAD>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEI_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for _NV_ENC_SEI_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the colour plane ID associated with the current input."]
    pub colourPlaneId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term referenceframe index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of slices to be forced to Intra in the current picture."]
    #[doc = "This option along with forceIntraSliceIdx[] array needs to be used with sliceMode = 3 only"]
    pub forceIntraSliceCount: u32,
    #[doc = "< [in]: Slice indices to be forced to intra in the current picture. Each slice index should be <= num_slices_in_picture -1. Index starts from 0 for first slice."]
    #[doc = "The number of entries in this array should be equal to forceIntraSliceCount"]
    pub forceIntraSliceIdx: *mut u32,
    #[doc = "< [in]: Specifies the H264 extension config parameters using this config."]
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 210usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).refPicFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).colourPlaneId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(colourPlaneId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArrayCnt as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArray as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceModeData as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrMarkFrameIdx as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUseFrameBitmap as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUsageMode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceCount as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceIdx as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).h264ExtPicParams as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(h264ExtPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved2 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_PIC_PARAMS_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the temporal id of the picture"]
    pub temporalId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3."]
    #[doc = "Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264"]
    #[doc = "Array element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I"]
    #[doc = "all other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT"]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0"]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term reference frame index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved2: [u32; 244usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).refPicFlag as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).temporalId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceModeData as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrMarkFrameIdx as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUseFrameBitmap as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUsageMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArrayCnt as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArray as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved3 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved3)
        )
    );
}
impl Default for _NV_ENC_PIC_PARAMS_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[doc = " Codec specific per-picture encoding parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    #[doc = "< [in]: H264 encode picture params."]
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    #[doc = "< [in]: HEVC encode picture params."]
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 256usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).h264PicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(h264PicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).hevcPicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(hevcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _NV_ENC_CODEC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Codec specific per-picture encoding parameters."]
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth."]
    pub inputPitch: u32,
    #[doc = "< [in]: Specifies bit-wise OR of encode picture flags. See ::NV_ENC_PIC_FLAGS enum."]
    pub encodePicFlags: u32,
    #[doc = "< [in]: Specifies the frame index associated with the input frame [optional]."]
    pub frameIdx: u32,
    #[doc = "< [in]: Specifies opaque data which is associated with the encoded frame, but not actually encoded in the output bitstream."]
    #[doc = "This opaque data can be used later to uniquely refer to the corresponding encoded frame. For example, it can be used"]
    #[doc = "for identifying the frame to be invalidated in the reference picture buffer, if lost at the client."]
    pub inputTimeStamp: u64,
    #[doc = "< [in]: Specifies duration of the input picture"]
    pub inputDuration: u64,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client"]
    #[doc = "should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream."]
    #[doc = "First 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of"]
    #[doc = "NV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is"]
    #[doc = "greater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use"]
    #[doc = "the default stream."]
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies an event to be signaled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies structure of the input picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [in]: Specifies the codec specific per-picture encoding parameters."]
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    #[doc = "< [in]: For H264 and Hevc, specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: For H264 and Hevc, Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 6usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 2usize],
    #[doc = "< [in]: Specifies the pointer to signed byte array containing value per MB for H264 and per CTB for HEVC in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DELTA, qpDeltaMap specifies QP modifier per MB for H264 and per CTB for HEVC. This QP modifier will be applied on top of the QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB for H264. This level value along with QP chosen by rate control is used to"]
    #[doc = "compute the QP modifier, which in turn is applied on top of QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DISABLED, value in qpDeltaMap will be ignored."]
    pub qpDeltaMap: *mut i8,
    #[doc = "< [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs for H264 and picWidthInCtbs * picHeightInCtbs for HEVC"]
    pub qpDeltaMapSize: u32,
    #[doc = "< [in]: Reserved bitfields and must be set to 0"]
    pub reservedBitFields: u32,
    #[doc = "< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints."]
    #[doc = "If not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0"]
    pub meHintRefPicDist: [u16; 2usize],
    #[doc = "< [in]: Specifies the input alpha buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    #[doc = "Applicable only when encoding hevc with alpha layer is enabled."]
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: [u32; 286usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved4: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS>(),
        3344usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputPitch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).encodePicFlags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(encodePicFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).frameIdx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputTimeStamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputDuration as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).outputBitstream as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).completionEvent as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).bufferFmt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).codecPicParams as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(codecPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintCountsPerBlock as *const _ as usize
        },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meExternalHints as *const _ as usize
        },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved1 as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved2 as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMap as *const _ as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMapSize as *const _ as usize
        },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMapSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reservedBitFields as *const _ as usize
        },
        1708usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reservedBitFields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintRefPicDist as *const _ as usize
        },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintRefPicDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).alphaBuffer as *const _ as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(alphaBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved3 as *const _ as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved4 as *const _ as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved4)
        )
    );
}
impl Default for _NV_ENC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MEONLY_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_MEONLY_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the reference frame pointer"]
    pub referenceFrame: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer."]
    #[doc = "Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must"]
    #[doc = "be equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this"]
    #[doc = "output buffer and assign it to NV_ENC_MEONLY_PARAMS::mvBuffer. All CUDA operations on this buffer must use the default stream."]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies an event to be signaled on completion of motion estimation"]
    #[doc = "of this Frame [only if operating in Asynchronous mode]."]
    #[doc = "Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies left or right viewID if NV_ENC_CONFIG_H264_MEONLY::bStereoEnable is set."]
    #[doc = "viewID can be 0,1 if bStereoEnable is set, 0 otherwise."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 243usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MEONLY_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MEONLY_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MEONLY_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputWidth as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputHeight as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputBuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).referenceFrame as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(referenceFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).mvBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).bufferFmt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).completionEvent as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).viewID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meHintCountsPerBlock as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meExternalHints as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved2 as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_MEONLY_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER."]
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Pointer to the bitstream buffer being locked."]
    pub outputBitstream: *mut ::std::os::raw::c_void,
    #[doc = "< [in, out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs."]
    pub sliceOffsets: *mut u32,
    #[doc = "< [out]: Frame no. for which the bitstream is being retrieved."]
    pub frameIdx: u32,
    #[doc = "< [out]: The NvEncodeAPI interface status for the locked picture."]
    pub hwEncodeStatus: u32,
    #[doc = "< [out]: Number of slices in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1."]
    pub numSlices: u32,
    #[doc = "< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr."]
    #[doc = "When HEVC alpha layer encoding is enabled, this field reports the total encoded size in bytes i.e it is the encoded size of the base plus the alpha layer."]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Presentation timestamp associated with the encoded output."]
    pub outputTimeStamp: u64,
    #[doc = "< [out]: Presentation duration associates with the encoded output."]
    pub outputDuration: u64,
    #[doc = "< [out]: Pointer to the generated output bitstream."]
    #[doc = "For MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to"]
    #[doc = "NV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Picture type of the encoded picture."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [out]: Structure of the generated output picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    #[doc = "< [out]: Total SATD cost for whole frame."]
    pub frameSatd: u32,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: Bitmap of LTR frames indices which were used for encoding this frame. Value of 0 if no LTR frames were used."]
    pub ltrFrameBitmap: u32,
    #[doc = "< [out]: TemporalId value of the frame when using temporalSVC encoding"]
    pub temporalId: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: [u32; 12usize],
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVY: i32,
    #[doc = "< [out]: Number of bytes generated for the alpha layer in the encoded output. Applicable only when HEVC with alpha encoding is enabled."]
    pub alphaLayerSizeInBytes: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 218usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_BITSTREAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputBitstream as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).sliceOffsets as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameIdx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).hwEncodeStatus as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(hwEncodeStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).numSlices as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamSizeInBytes as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputTimeStamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputDuration as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamBufferPtr as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureType as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameAvgQP as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameSatd as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameSatd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameIdx as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameBitmap as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).temporalId as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).intraMBCount as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).interMBCount as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVX as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVY as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).alphaLayerSizeInBytes as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(alphaLayerSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved1 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_LOCK_BITSTREAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::std::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER."]
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \\p bufferDataPtr."]
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Pitch of the locked input buffer."]
    pub pitch: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).bufferDataPtr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(bufferDataPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_LOCK_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub subResourceIndex: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub inputResource: *mut ::std::os::raw::c_void,
    #[doc = "< [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API."]
    pub mappedResource: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer."]
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]:  Reserved and must be set to 0."]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MAP_INPUT_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).inputResource as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(inputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).registeredResource as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedResource as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedBufferFmt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedBufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_MAP_INPUT_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
#[doc = " NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,"]
#[doc = " when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    #[doc = "< [in]: The name of the texture to be used."]
    pub texture: u32,
    #[doc = "< [in]: Accepted values are GL_TEXTURE_RECTANGLE and GL_TEXTURE_2D."]
    pub target: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_OPENGL_TEX() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>())).texture as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>())).target as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(target)
        )
    );
}
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
#[doc = " NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,"]
#[doc = " when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
#[doc = " \\struct NV_ENC_FENCE_POINT_D3D12"]
#[doc = " Fence and fence value for synchronization."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_FENCE_POINT_D3D12 {
    #[doc = "< [in]: Pointer to ID3D12Fence. This fence object is used for synchronization."]
    pub pFence: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Fence value to reach or exceed before the GPU operation or"]
    #[doc = "fence value to set the fence to, after the GPU operation."]
    pub value: u64,
}
#[test]
fn bindgen_test_layout__NV_ENC_FENCE_POINT_D3D12() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_FENCE_POINT_D3D12>())).pFence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(pFence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_FENCE_POINT_D3D12>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(value)
        )
    );
}
impl Default for _NV_ENC_FENCE_POINT_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct NV_ENC_FENCE_POINT_D3D12"]
#[doc = " Fence and fence value for synchronization."]
pub type NV_ENC_FENCE_POINT_D3D12 = _NV_ENC_FENCE_POINT_D3D12;
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_D3D12"]
#[doc = " NV_ENC_PIC_PARAMS::inputBuffer and NV_ENC_PIC_PARAMS::alphaBuffer must be a pointer to a struct of this type,"]
#[doc = " when D3D12 interface is used"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_D3D12 {
    #[doc = "< [in]: Specifies the input surface pointer. Client must use a pointer obtained from NvEncRegisterResource() in NV_ENC_REGISTER_RESOURCE::registeredResource"]
    #[doc = "when registering input surface."]
    pub pInputBuffer: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Specifies the input fence and corresponding fence value to do GPU wait."]
    #[doc = "This fence will be used to do GPU wait until the specified fence reaches or exceeds the specified value."]
    pub inputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 16usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_D3D12() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        216usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_D3D12>())).pInputBuffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(pInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_D3D12>())).inputFencePoint as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(inputFencePoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_D3D12>())).reserved1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INPUT_RESOURCE_D3D12>())).reserved2 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_INPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_D3D12"]
#[doc = " NV_ENC_PIC_PARAMS::inputBuffer and NV_ENC_PIC_PARAMS::alphaBuffer must be a pointer to a struct of this type,"]
#[doc = " when D3D12 interface is used"]
pub type NV_ENC_INPUT_RESOURCE_D3D12 = _NV_ENC_INPUT_RESOURCE_D3D12;
#[doc = " \\struct _NV_ENC_OUTPUT_RESOURCE_D3D12"]
#[doc = " NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_LOCK_BITSTREAM::outputBitstream must be a pointer to a struct of this type,"]
#[doc = " when D3D12 interface is used"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    #[doc = "< [in]: Specifies the output buffer pointer. Client must use a pointer obtained from NvEncRegisterResource() in NV_ENC_REGISTER_RESOURCE::registeredResource"]
    #[doc = "when registering output bitstream buffer"]
    pub pOutputBuffer: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Specifies the output fence and corresponding fence value to set after GPU operation is finished."]
    pub outputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 16usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OUTPUT_RESOURCE_D3D12() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        216usize,
        concat!("Size of: ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OUTPUT_RESOURCE_D3D12>())).pOutputBuffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(pOutputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OUTPUT_RESOURCE_D3D12>())).outputFencePoint as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(outputFencePoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OUTPUT_RESOURCE_D3D12>())).reserved1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OUTPUT_RESOURCE_D3D12>())).reserved2 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_OUTPUT_RESOURCE_D3D12"]
#[doc = " NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_LOCK_BITSTREAM::outputBitstream must be a pointer to a struct of this type,"]
#[doc = " when D3D12 interface is used"]
pub type NV_ENC_OUTPUT_RESOURCE_D3D12 = _NV_ENC_OUTPUT_RESOURCE_D3D12;
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_REGISTER_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the type of resource to be registered."]
    #[doc = "Supported values are"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    #[doc = "< [in]: Input frame width."]
    pub width: u32,
    #[doc = "< [in]: Input frame height."]
    pub height: u32,
    #[doc = "< [in]: Input buffer pitch."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX resources, set this to 0."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR resources, set this to"]
    #[doc = "the pitch as obtained from cuMemAllocPitch(), or to the width in"]
    #[doc = "bytes (if this resource was created by using cuMemAlloc()). This"]
    #[doc = "value must be a multiple of 4."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY resources, set this to the"]
    #[doc = "width of the allocation in bytes (i.e."]
    #[doc = "CUDA_ARRAY3D_DESCRIPTOR::Width * CUDA_ARRAY3D_DESCRIPTOR::NumChannels)."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX resources, set this to the"]
    #[doc = "texture width multiplied by the number of components in the texture"]
    #[doc = "format."]
    pub pitch: u32,
    #[doc = "< [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces."]
    pub subResourceIndex: u32,
    #[doc = "< [in]: Handle to the resource that is being registered."]
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Buffer format of resource to be registered."]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Usage of resource to be registered."]
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    #[doc = "< [in]: Specifies the pointer to input fence and corresponding fence value to do GPU wait."]
    #[doc = "To be used only when NV_ENC_REGISTER_RESOURCE::resourceToRegister represents D3D12 surface and"]
    #[doc = "NV_ENC_BUFFER_USAGE::bufferUsage is NV_ENC_INPUT_IMAGE."]
    #[doc = "This fence will be used to do GPU wait until the specified fence reaches or exceeds the specified value."]
    pub pInputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Specifies the pointer to output fence and corresponding fence value to set after GPU operation is finished."]
    #[doc = "To be used only when NV_ENC_REGISTER_RESOURCE::resourceToRegister represents D3D12 surface and"]
    #[doc = "NV_ENC_BUFFER_USAGE::bufferUsage is NV_ENC_INPUT_IMAGE."]
    pub pOutputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 247usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 60usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_REGISTER_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).pitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceToRegister as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceToRegister)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).registeredResource as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferFormat as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferUsage as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).pInputFencePoint as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pInputFencePoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).pOutputFencePoint as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pOutputFencePoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved1 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved2 as *const _ as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_REGISTER_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_STAT {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_STAT_VER."]
    pub version: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Specifies the pointer to output bitstream."]
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Size of generated bitstream in bytes."]
    pub bitStreamSize: u32,
    #[doc = "< [out]: Picture type of encoded picture. See ::NV_ENC_PIC_TYPE."]
    pub picType: u32,
    #[doc = "< [out]: Offset of last valid bytes of completed bitstream"]
    pub lastValidByteOffset: u32,
    #[doc = "< [out]: Offsets of each slice"]
    pub sliceOffsets: [u32; 16usize],
    #[doc = "< [out]: Picture number"]
    pub picIdx: u32,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame."]
    pub averageMVY: i32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 226usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_STAT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_STAT>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).outputBitStream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(outputBitStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).bitStreamSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(bitStreamSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_STAT>())).lastValidByteOffset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(lastValidByteOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).sliceOffsets as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picIdx as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).frameAvgQP as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).ltrFrameIdx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).intraMBCount as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).interMBCount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).averageMVX as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).averageMVY as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved1 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_STAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]:  Specifies the size of the spsppsBuffer provided by the client"]
    pub inBufferSize: u32,
    #[doc = "< [in]:  Specifies the SPS id to be used in sequence header. Default value is 0."]
    pub spsId: u32,
    #[doc = "< [in]:  Specifies the PPS id to be used in picture header. Default value is 0."]
    pub ppsId: u32,
    #[doc = "< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize."]
    #[doc = "It is the client's responsibility to manage this memory."]
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Size of the sequence and picture header in bytes."]
    pub outSPSPPSPayloadSize: *mut u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: [u32; 250usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_SEQUENCE_PARAM_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).inBufferSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(inBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).ppsId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsppsBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsppsBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).outSPSPPSPayloadSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(outSPSPPSPayloadSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved2 as *const _
                as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[doc = " Event registration/unregistration parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_EVENT_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_EVENT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_EVENT_PARAMS>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_EVENT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).completionEvent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_EVENT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Event registration/unregistration parameters."]
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[doc = " Encoder Session Creation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specified the device Type"]
    pub deviceType: NV_ENC_DEVICE_TYPE,
    #[doc = "< [in]: Pointer to client device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: API version. Should be set to NVENCAPI_VERSION."]
    pub apiVersion: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).deviceType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).apiVersion as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved1 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved2 as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder Session Creation parameters"]
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
extern "C" {
    #[doc = " \\brief Opens an encoding session."]
    #[doc = ""]
    #[doc = " Deprecated."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_ERR_INVALID_CALL\\n"]
    #[doc = ""]
    pub fn NvEncOpenEncodeSession(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported encode GUIDs."]
    #[doc = ""]
    #[doc = " The function returns the number of codec GUIDs supported by the NvEncodeAPI"]
    #[doc = " interface."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [out] encodeGUIDCount"]
    #[doc = "   Number of supported encode GUIDs."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported encoder codec GUIDs."]
    #[doc = ""]
    #[doc = " The function returns an array of codec GUIDs supported by the NvEncodeAPI interface."]
    #[doc = " The client must allocate an array where the NvEncodeAPI interface can"]
    #[doc = " fill the supported GUIDs and pass the pointer in \\p *GUIDs parameter."]
    #[doc = " The size of the array can be determined by using ::NvEncGetEncodeGUIDCount() API."]
    #[doc = " The Nvidia Encoding interface returns the number of codec GUIDs it has actually"]
    #[doc = " filled in the GUID array in the \\p GUIDCount parameter."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] guidArraySize"]
    #[doc = "   Number of GUIDs to retrieved. Should be set to the number retrieved using"]
    #[doc = "   ::NvEncGetEncodeGUIDCount."]
    #[doc = " \\param [out] GUIDs"]
    #[doc = "   Array of supported Encode GUIDs."]
    #[doc = " \\param [out] GUIDCount"]
    #[doc = "   Number of supported Encode GUIDs."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported profile GUIDs."]
    #[doc = ""]
    #[doc = " The function returns the number of profile GUIDs supported for a given codec."]
    #[doc = " The client must first enumerate the codec GUIDs supported by the NvEncodeAPI"]
    #[doc = " interface. After determining the codec GUID, it can query the NvEncodeAPI"]
    #[doc = " interface to determine the number of profile GUIDs supported for a particular"]
    #[doc = " codec GUID."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   The codec GUID for which the profile GUIDs are being enumerated."]
    #[doc = " \\param [out] encodeProfileGUIDCount"]
    #[doc = "   Number of encode profiles supported for the given encodeGUID."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported encode profile GUIDs."]
    #[doc = ""]
    #[doc = " The function returns an array of supported profile GUIDs for a particular"]
    #[doc = " codec GUID. The client must allocate an array where the NvEncodeAPI interface"]
    #[doc = " can populate the profile GUIDs. The client can determine the array size using"]
    #[doc = " ::NvEncGetEncodeProfileGUIDCount() API. The client must also validiate that the"]
    #[doc = " NvEncodeAPI interface supports the GUID the client wants to pass as \\p encodeGUID"]
    #[doc = " parameter."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   The encode GUID whose profile GUIDs are being enumerated."]
    #[doc = " \\param [in] guidArraySize"]
    #[doc = "   Number of GUIDs to be retrieved. Should be set to the number retrieved using"]
    #[doc = "   ::NvEncGetEncodeProfileGUIDCount."]
    #[doc = " \\param [out] profileGUIDs"]
    #[doc = "   Array of supported Encode Profile GUIDs"]
    #[doc = " \\param [out] GUIDCount"]
    #[doc = "   Number of valid encode profile GUIDs in \\p profileGUIDs array."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieve the number of supported Input formats."]
    #[doc = ""]
    #[doc = " The function returns the number of supported input formats. The client must"]
    #[doc = " query the NvEncodeAPI interface to determine the supported input formats"]
    #[doc = " before creating the input surfaces."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the number of supported input formats"]
    #[doc = "   is to be retrieved."]
    #[doc = " \\param [out] inputFmtCount"]
    #[doc = "   Number of input formats supported for specified Encode GUID."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported Input formats"]
    #[doc = ""]
    #[doc = " Returns an array of supported input formats  The client must use the input"]
    #[doc = " format to create input surface using ::NvEncCreateInputBuffer() API."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the number of supported input formats"]
    #[doc = "   is to be retrieved."]
    #[doc = "\\param [in] inputFmtArraySize"]
    #[doc = "   Size input format count array passed in \\p inputFmts."]
    #[doc = "\\param [out] inputFmts"]
    #[doc = "   Array of input formats supported for this Encode GUID."]
    #[doc = "\\param [out] inputFmtCount"]
    #[doc = "   The number of valid input format types returned by the NvEncodeAPI"]
    #[doc = "   interface in \\p inputFmts array."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetInputFormats(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the capability value for a specified encoder attribute."]
    #[doc = ""]
    #[doc = " The function returns the capability value for a given encoder attribute. The"]
    #[doc = " client must validate the encodeGUID using ::NvEncGetEncodeGUIDs() API before"]
    #[doc = " calling this function. The encoder attribute being queried are enumerated in"]
    #[doc = " ::NV_ENC_CAPS_PARAM enum."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the capability attribute is to be retrieved."]
    #[doc = " \\param [in] capsParam"]
    #[doc = "   Used to specify attribute being queried. Refer ::NV_ENC_CAPS_PARAM for  more"]
    #[doc = " details."]
    #[doc = " \\param [out] capsVal"]
    #[doc = "   The value corresponding to the capability attribute being queried."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported preset GUIDs."]
    #[doc = ""]
    #[doc = " The function returns the number of preset GUIDs available for a given codec."]
    #[doc = " The client must validate the codec GUID using ::NvEncGetEncodeGUIDs() API"]
    #[doc = " before calling this function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the number of supported presets is to"]
    #[doc = "   be retrieved."]
    #[doc = " \\param [out] encodePresetGUIDCount"]
    #[doc = "   Receives the number of supported preset GUIDs."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Receives an array of supported encoder preset GUIDs."]
    #[doc = ""]
    #[doc = " The function returns an array of encode preset GUIDs available for a given codec."]
    #[doc = " The client can directly use one of the preset GUIDs based upon the use case"]
    #[doc = " or target device. The preset GUID chosen can be directly used in"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::presetGUID parameter to ::NvEncEncodePicture() API."]
    #[doc = " Alternately client can  also use the preset GUID to retrieve the encoding config"]
    #[doc = " parameters being used by NvEncodeAPI interface for that given preset, using"]
    #[doc = " ::NvEncGetEncodePresetConfig() API. It can then modify preset config parameters"]
    #[doc = " as per its use case and send it to NvEncodeAPI interface as part of"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::encodeConfig parameter for NvEncInitializeEncoder()"]
    #[doc = " API."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the list of supported presets is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [in] guidArraySize"]
    #[doc = "   Size of array of preset GUIDs passed in \\p preset GUIDs"]
    #[doc = " \\param [out] presetGUIDs"]
    #[doc = "   Array of supported Encode preset GUIDs from the NvEncodeAPI interface"]
    #[doc = "   to client."]
    #[doc = " \\param [out] encodePresetGUIDCount"]
    #[doc = "   Receives the number of preset GUIDs returned by the NvEncodeAPI"]
    #[doc = "   interface."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Returns a preset config structure supported for given preset GUID."]
    #[doc = ""]
    #[doc = " The function returns a preset config structure for a given preset GUID. Before"]
    #[doc = " using this function the client must enumerate the preset GUIDs available for"]
    #[doc = " a given codec. The preset config structure can be modified by the client depending"]
    #[doc = " upon its use case and can be then used to initialize the encoder using"]
    #[doc = " ::NvEncInitializeEncoder() API. The client can use this function only if it"]
    #[doc = " wants to modify the NvEncodeAPI preset configuration, otherwise it can"]
    #[doc = " directly use the preset GUID."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the list of supported presets is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [in] presetGUID"]
    #[doc = "   Preset GUID, corresponding to which the Encoding configurations is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [out] presetConfig"]
    #[doc = "   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for"]
    #[doc = "    more details."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Returns a preset config structure supported for given preset GUID."]
    #[doc = ""]
    #[doc = " The function returns a preset config structure for a given preset GUID and tuning info."]
    #[doc = " NvEncGetEncodePresetConfigEx() API is not applicable to H264 and HEVC meonly mode."]
    #[doc = " Before using this function the client must enumerate the preset GUIDs available for"]
    #[doc = " a given codec. The preset config structure can be modified by the client depending"]
    #[doc = " upon its use case and can be then used to initialize the encoder using"]
    #[doc = " ::NvEncInitializeEncoder() API. The client can use this function only if it"]
    #[doc = " wants to modify the NvEncodeAPI preset configuration, otherwise it can"]
    #[doc = " directly use the preset GUID."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encodeGUID"]
    #[doc = "   Encode GUID, corresponding to which the list of supported presets is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [in] presetGUID"]
    #[doc = "   Preset GUID, corresponding to which the Encoding configurations is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [in] tuningInfo"]
    #[doc = "   tuning info, corresponding to which the Encoding configurations is to be"]
    #[doc = "   retrieved."]
    #[doc = " \\param [out] presetConfig"]
    #[doc = "   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for"]
    #[doc = "    more details."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodePresetConfigEx(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Initialize the encoder."]
    #[doc = ""]
    #[doc = " This API must be used to initialize the encoder. The initialization parameter"]
    #[doc = " is passed using \\p *createEncodeParams  The client must send the following"]
    #[doc = " fields of the _NV_ENC_INITIALIZE_PARAMS structure with a valid value."]
    #[doc = " - NV_ENC_INITIALIZE_PARAMS::encodeGUID"]
    #[doc = " - NV_ENC_INITIALIZE_PARAMS::encodeWidth"]
    #[doc = " - NV_ENC_INITIALIZE_PARAMS::encodeHeight"]
    #[doc = ""]
    #[doc = " The client can pass a preset GUID directly to the NvEncodeAPI interface using"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::presetGUID field. If the client doesn't pass"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::encodeConfig structure, the codec specific parameters"]
    #[doc = " will be selected based on the preset GUID. The preset GUID must have been"]
    #[doc = " validated by the client using ::NvEncGetEncodePresetGUIDs() API."]
    #[doc = " If the client passes a custom ::_NV_ENC_CONFIG structure through"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::encodeConfig , it will override the codec specific parameters"]
    #[doc = " based on the preset GUID. It is recommended that even if the client passes a custom config,"]
    #[doc = " it should also send a preset GUID. In this case, the preset GUID passed by the client"]
    #[doc = " will not override any of the custom config parameters programmed by the client,"]
    #[doc = " it is only used as a hint by the NvEncodeAPI interface to determine certain encoder parameters"]
    #[doc = " which are not exposed to the client."]
    #[doc = ""]
    #[doc = " There are two modes of operation for the encoder namely:"]
    #[doc = " - Asynchronous mode"]
    #[doc = " - Synchronous mode"]
    #[doc = ""]
    #[doc = " The client can select asynchronous or synchronous mode by setting the \\p"]
    #[doc = " enableEncodeAsync field in ::_NV_ENC_INITIALIZE_PARAMS to 1 or 0 respectively."]
    #[doc = "\\par Asynchronous mode of operation:"]
    #[doc = " The Asynchronous mode can be enabled by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1."]
    #[doc = " The client operating in asynchronous mode must allocate completion event object"]
    #[doc = " for each output buffer and pass the completion event object in the"]
    #[doc = " ::NvEncEncodePicture() API. The client can create another thread and wait on"]
    #[doc = " the event object to be signaled by NvEncodeAPI interface on completion of the"]
    #[doc = " encoding process for the output frame. This should unblock the main thread from"]
    #[doc = " submitting work to the encoder. When the event is signaled the client can call"]
    #[doc = " NvEncodeAPI interfaces to copy the bitstream data using ::NvEncLockBitstream()"]
    #[doc = " API. This is the preferred mode of operation."]
    #[doc = ""]
    #[doc = " NOTE: Asynchronous mode is not supported on Linux."]
    #[doc = ""]
    #[doc = "\\par Synchronous mode of operation:"]
    #[doc = " The client can select synchronous mode by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0."]
    #[doc = " The client working in synchronous mode can work in a single threaded or multi"]
    #[doc = " threaded mode. The client need not allocate any event objects. The client can"]
    #[doc = " only lock the bitstream data after NvEncodeAPI interface has returned"]
    #[doc = " ::NV_ENC_SUCCESS from encode picture. The NvEncodeAPI interface can return"]
    #[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT error code from ::NvEncEncodePicture() API. The"]
    #[doc = " client must not lock the output buffer in such case but should send the next"]
    #[doc = " frame for encoding. The client must keep on calling ::NvEncEncodePicture() API"]
    #[doc = " until it returns ::NV_ENC_SUCCESS. \\n"]
    #[doc = " The client must always lock the bitstream data in order in which it has submitted."]
    #[doc = " This is true for both asynchronous and synchronous mode."]
    #[doc = ""]
    #[doc = "\\par Picture type decision:"]
    #[doc = " If the client is taking the picture type decision and it must disable the picture"]
    #[doc = " type decision module in NvEncodeAPI by setting NV_ENC_INITIALIZE_PARAMS::enablePTD"]
    #[doc = " to 0. In this case the client is  required to send the picture in encoding"]
    #[doc = " order to NvEncodeAPI by doing the re-ordering for B frames. \\n"]
    #[doc = " If the client doesn't want to take the picture type decision it can enable"]
    #[doc = " picture type decision module in the NvEncodeAPI interface by setting"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::enablePTD to 1 and send the input pictures in display"]
    #[doc = " order."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] createEncodeParams"]
    #[doc = "   Refer ::_NV_ENC_INITIALIZE_PARAMS for details."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates Input buffer."]
    #[doc = ""]
    #[doc = " This function is used to allocate an input buffer. The client must enumerate"]
    #[doc = " the input buffer format before allocating the input buffer resources. The"]
    #[doc = " NV_ENC_INPUT_PTR returned by the NvEncodeAPI interface in the"]
    #[doc = " NV_ENC_CREATE_INPUT_BUFFER::inputBuffer field can be directly used in"]
    #[doc = " ::NvEncEncodePicture() API. The number of input buffers to be allocated by the"]
    #[doc = " client must be at least 4 more than the number of B frames being used for encoding."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] createInputBufferParams"]
    #[doc = "  Pointer to the ::NV_ENC_CREATE_INPUT_BUFFER structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release an input buffers."]
    #[doc = ""]
    #[doc = " This function is used to free an input buffer. If the client has allocated"]
    #[doc = " any input buffer using ::NvEncCreateInputBuffer() API, it must free those"]
    #[doc = " input buffers by calling this function. The client must release the input"]
    #[doc = " buffers before destroying the encoder using ::NvEncDestroyEncoder() API."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] inputBuffer"]
    #[doc = "   Pointer to the input buffer to be released."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Set input and output CUDA stream for specified encoder attribute."]
    #[doc = ""]
    #[doc = " Encoding may involve CUDA pre-processing on the input and post-processing on encoded output."]
    #[doc = " This function is used to set input and output CUDA streams to pipeline the CUDA pre-processing"]
    #[doc = " and post-processing tasks. Clients should call this function before the call to"]
    #[doc = " NvEncUnlockInputBuffer(). If this function is not called, the default CUDA stream is used for"]
    #[doc = " input and output processing. After a successful call to this function, the streams specified"]
    #[doc = " in that call will replace the previously-used streams."]
    #[doc = " This API is supported for NVCUVID interface only."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] inputStream"]
    #[doc = "   Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::inputFrame for encode."]
    #[doc = "   In case of ME-only mode, inputStream is used to process ::NV_ENC_MEONLY_PARAMS::inputBuffer and"]
    #[doc = "   ::NV_ENC_MEONLY_PARAMS::referenceFrame"]
    #[doc = " \\param [in] outputStream"]
    #[doc = "  Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::outputBuffer for encode."]
    #[doc = "  In case of ME-only mode, outputStream is used to process ::NV_ENC_MEONLY_PARAMS::mvBuffer"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncSetIOCudaStreams(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates an output bitstream buffer"]
    #[doc = ""]
    #[doc = " This function is used to allocate an output bitstream buffer and returns a"]
    #[doc = " NV_ENC_OUTPUT_PTR to bitstream  buffer to the client in the"]
    #[doc = " NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer field."]
    #[doc = " The client can only call this function after the encoder session has been"]
    #[doc = " initialized using ::NvEncInitializeEncoder() API. The minimum number of output"]
    #[doc = " buffers allocated by the client must be at least 4 more than the number of B"]
    #[doc = " B frames being used for encoding. The client can only access the output"]
    #[doc = " bitstream data by locking the \\p bitstreamBuffer using the ::NvEncLockBitstream()"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] createBitstreamBufferParams"]
    #[doc = "   Pointer ::NV_ENC_CREATE_BITSTREAM_BUFFER for details."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release a bitstream buffer."]
    #[doc = ""]
    #[doc = " This function is used to release the output bitstream buffer allocated using"]
    #[doc = " the ::NvEncCreateBitstreamBuffer() function. The client must release the output"]
    #[doc = " bitstreamBuffer using this function before destroying the encoder session."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] bitstreamBuffer"]
    #[doc = "   Pointer to the bitstream buffer being released."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Submit an input picture for encoding."]
    #[doc = ""]
    #[doc = " This function is used to submit an input picture buffer for encoding. The"]
    #[doc = " encoding parameters are passed using \\p *encodePicParams which is a pointer"]
    #[doc = " to the ::_NV_ENC_PIC_PARAMS structure."]
    #[doc = ""]
    #[doc = " If the client has set NV_ENC_INITIALIZE_PARAMS::enablePTD to 0, then it must"]
    #[doc = " send a valid value for the following fields."]
    #[doc = " - NV_ENC_PIC_PARAMS::pictureType"]
    #[doc = " - NV_ENC_PIC_PARAMS_H264::displayPOCSyntax (H264 only)"]
    #[doc = " - NV_ENC_PIC_PARAMS_H264::frameNumSyntax(H264 only)"]
    #[doc = " - NV_ENC_PIC_PARAMS_H264::refPicFlag(H264 only)"]
    #[doc = ""]
    #[doc = "\\par MVC Encoding:"]
    #[doc = " For MVC encoding the client must call encode picture API for each view separately"]
    #[doc = " and must pass valid view id in NV_ENC_PIC_PARAMS_MVC::viewID field. Currently"]
    #[doc = " NvEncodeAPI only support stereo MVC so client must send viewID as 0 for base"]
    #[doc = " view and view ID as 1 for dependent view."]
    #[doc = ""]
    #[doc = "\\par Asynchronous Encoding"]
    #[doc = " If the client has enabled asynchronous mode of encoding by setting"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 in the ::NvEncInitializeEncoder()"]
    #[doc = " API ,then the client must send a valid NV_ENC_PIC_PARAMS::completionEvent."]
    #[doc = " Incase of asynchronous mode of operation, client can queue the ::NvEncEncodePicture()"]
    #[doc = " API commands from the main thread and then queue output buffers to be processed"]
    #[doc = " to a secondary worker thread. Before the locking the output buffers in the"]
    #[doc = " secondary thread , the client must wait on NV_ENC_PIC_PARAMS::completionEvent"]
    #[doc = " it has queued in ::NvEncEncodePicture() API call. The client must always process"]
    #[doc = " completion event and the output buffer in the same order in which they have been"]
    #[doc = " submitted for encoding. The NvEncodeAPI interface is responsible for any"]
    #[doc = " re-ordering required for B frames and will always ensure that encoded bitstream"]
    #[doc = " data is written in the same order in which output buffer is submitted."]
    #[doc = " The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for"]
    #[doc = " some ::NvEncEncodePicture() API calls but the client must not treat it as a fatal error."]
    #[doc = " The NvEncodeAPI interface might not be able to submit an input picture buffer for encoding"]
    #[doc = " immediately due to re-ordering for B frames."]
    #[doc = "\\code"]
    #[doc = "The below example shows how  asynchronous encoding in case of 1 B frames"]
    #[doc = "------------------------------------------------------------------------"]
    #[doc = "Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)"]
    #[doc = "and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to"]
    #[doc = "keep a copy of the input buffers for re-ordering and it allocates following"]
    #[doc = "internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI"]
    #[doc = "and the client is not responsible for the allocating or freeing the memory of"]
    #[doc = "the internal buffers."]
    #[doc = ""]
    #[doc = "a) The client main thread will queue the following encode frame calls."]
    #[doc = "Note the picture type is unknown to the client, the decision is being taken by"]
    #[doc = "NvEncodeAPI interface. The client should pass ::_NV_ENC_PIC_PARAMS parameter"]
    #[doc = "consisting of allocated input buffer, output buffer and output events in successive"]
    #[doc = "::NvEncEncodePicture() API calls along with other required encode picture params."]
    #[doc = "For example:"]
    #[doc = "1st EncodePicture parameters - (I1, O1, E1)"]
    #[doc = "2nd EncodePicture parameters - (I2, O2, E2)"]
    #[doc = "3rd EncodePicture parameters - (I3, O3, E3)"]
    #[doc = ""]
    #[doc = "b) NvEncodeAPI SW will receive the following encode Commands from the client."]
    #[doc = "The left side shows input from client in the form (Input buffer, Output Buffer,"]
    #[doc = "Output Event). The right hand side shows a possible picture type decision take by"]
    #[doc = "the NvEncodeAPI interface."]
    #[doc = "(I1, O1, E1)    ---P1 Frame"]
    #[doc = "(I2, O2, E2)    ---B2 Frame"]
    #[doc = "(I3, O3, E3)    ---P3 Frame"]
    #[doc = ""]
    #[doc = "c) NvEncodeAPI interface will make a copy of the input buffers to its internal"]
    #[doc = "buffers for re-ordering. These copies are done as part of nvEncEncodePicture"]
    #[doc = "function call from the client and NvEncodeAPI interface is responsible for"]
    #[doc = "synchronization of copy operation with the actual encoding operation."]
    #[doc = "I1 --> NvI1"]
    #[doc = "I2 --> NvI2"]
    #[doc = "I3 --> NvI3"]
    #[doc = ""]
    #[doc = "d) The NvEncodeAPI encodes I1 as P frame and submits I1 to encoder HW and returns ::NV_ENC_SUCCESS."]
    #[doc = "The NvEncodeAPI tries to encode I2 as B frame and fails with ::NV_ENC_ERR_NEED_MORE_INPUT error code."]
    #[doc = "The error is not fatal and it notifies client that I2 is not submitted to encoder immediately."]
    #[doc = "The NvEncodeAPI encodes I3 as P frame and submits I3 for encoding which will be used as  backward"]
    #[doc = "reference frame for I2. The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS."]
    #[doc = "Both the submission are part of the same ::NvEncEncodePicture() function call."]
    #[doc = ""]
    #[doc = "e) After returning from ::NvEncEncodePicture() call , the client must queue the output"]
    #[doc = "bitstream  processing work to the secondary thread. The output bitstream processing"]
    #[doc = "for asynchronous mode consist of first waiting on completion event(E1, E2..)"]
    #[doc = "and then locking the output bitstream buffer(O1, O2..) for reading the encoded"]
    #[doc = "data. The work queued to the secondary thread by the client is in the following order"]
    #[doc = "(I1, O1, E1)"]
    #[doc = "(I2, O2, E2)"]
    #[doc = "(I3, O3, E3)"]
    #[doc = "Note they are in the same order in which client calls ::NvEncEncodePicture() API"]
    #[doc = "in \\p step a)."]
    #[doc = ""]
    #[doc = "f) NvEncodeAPI interface  will do the re-ordering such that Encoder HW will receive"]
    #[doc = "the following encode commands:"]
    #[doc = "(NvI1, O1, E1)   ---P1 Frame"]
    #[doc = "(NvI3, O2, E2)   ---P3 Frame"]
    #[doc = "(NvI2, O3, E3)   ---B2 frame"]
    #[doc = ""]
    #[doc = "g) After the encoding operations are completed, the events will be signaled"]
    #[doc = "by NvEncodeAPI interface in the following order :"]
    #[doc = "(O1, E1) ---P1 Frame ,output bitstream copied to O1 and event E1 signaled."]
    #[doc = "(O2, E2) ---P3 Frame ,output bitstream copied to O2 and event E2 signaled."]
    #[doc = "(O3, E3) ---B2 Frame ,output bitstream copied to O3 and event E3 signaled."]
    #[doc = ""]
    #[doc = "h) The client must lock the bitstream data using ::NvEncLockBitstream() API in"]
    #[doc = "the order O1,O2,O3  to read the encoded data, after waiting for the events"]
    #[doc = "to be signaled in the same order i.e E1, E2 and E3.The output processing is"]
    #[doc = "done in the secondary thread in the following order:"]
    #[doc = "Waits on E1, copies encoded bitstream from O1"]
    #[doc = "Waits on E2, copies encoded bitstream from O2"]
    #[doc = "Waits on E3, copies encoded bitstream from O3"]
    #[doc = ""]
    #[doc = "-Note the client will receive the events signaling and output buffer in the"]
    #[doc = "same order in which they have submitted for encoding."]
    #[doc = "-Note the LockBitstream will have picture type field which will notify the"]
    #[doc = "output picture type to the clients."]
    #[doc = "-Note the input, output buffer and the output completion event are free to be"]
    #[doc = "reused once NvEncodeAPI interfaced has signaled the event and the client has"]
    #[doc = "copied the data from the output buffer."]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = "\\par Synchronous Encoding"]
    #[doc = " The client can enable synchronous mode of encoding by setting"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 in ::NvEncInitializeEncoder() API."]
    #[doc = " The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for"]
    #[doc = " some ::NvEncEncodePicture() API calls when NV_ENC_INITIALIZE_PARAMS::enablePTD"]
    #[doc = " is set to 1, but the client must not treat it as a fatal error. The NvEncodeAPI"]
    #[doc = " interface might not be able to submit an input picture buffer for encoding"]
    #[doc = " immediately due to re-ordering for B frames. The NvEncodeAPI interface cannot"]
    #[doc = " submit the input picture which is decided to be encoded as B frame as it waits"]
    #[doc = " for backward reference from  temporally subsequent frames. This input picture"]
    #[doc = " is buffered internally and waits for more input picture to arrive. The client"]
    #[doc = " must not call ::NvEncLockBitstream() API on the output buffers whose"]
    #[doc = " ::NvEncEncodePicture() API returns ::NV_ENC_ERR_NEED_MORE_INPUT. The client must"]
    #[doc = " wait for the NvEncodeAPI interface to return ::NV_ENC_SUCCESS before locking the"]
    #[doc = " output bitstreams to read the encoded bitstream data. The following example"]
    #[doc = " explains the scenario with synchronous encoding with 2 B frames."]
    #[doc = "\\code"]
    #[doc = "The below example shows how  synchronous encoding works in case of 1 B frames"]
    #[doc = "-----------------------------------------------------------------------------"]
    #[doc = "Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)"]
    #[doc = "and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to"]
    #[doc = "keep a copy of the input buffers for re-ordering and it allocates following"]
    #[doc = "internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI"]
    #[doc = "and the client is not responsible for the allocating or freeing the memory of"]
    #[doc = "the internal buffers."]
    #[doc = ""]
    #[doc = "The client calls ::NvEncEncodePicture() API with input buffer I1 and output buffer O1."]
    #[doc = "The NvEncodeAPI decides to encode I1 as P frame and submits it to encoder"]
    #[doc = "HW and returns ::NV_ENC_SUCCESS."]
    #[doc = "The client can now read the encoded data by locking the output O1 by calling"]
    #[doc = "NvEncLockBitstream API."]
    #[doc = ""]
    #[doc = "The client calls ::NvEncEncodePicture() API with input buffer I2 and output buffer O2."]
    #[doc = "The NvEncodeAPI decides to encode I2 as B frame and buffers I2 by copying it"]
    #[doc = "to internal buffer and returns ::NV_ENC_ERR_NEED_MORE_INPUT."]
    #[doc = "The error is not fatal and it notifies client that it cannot read the encoded"]
    #[doc = "data by locking the output O2 by calling ::NvEncLockBitstream() API without submitting"]
    #[doc = "more work to the NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = "The client calls ::NvEncEncodePicture() with input buffer I3 and output buffer O3."]
    #[doc = "The NvEncodeAPI decides to encode I3 as P frame and it first submits I3 for"]
    #[doc = "encoding which will be used as backward reference frame for I2."]
    #[doc = "The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS. Both"]
    #[doc = "the submission are part of the same ::NvEncEncodePicture() function call."]
    #[doc = "The client can now read the encoded data for both the frames by locking the output"]
    #[doc = "O2 followed by  O3 ,by calling ::NvEncLockBitstream() API."]
    #[doc = ""]
    #[doc = "The client must always lock the output in the same order in which it has submitted"]
    #[doc = "to receive the encoded bitstream in correct encoding order."]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] encodePicParams"]
    #[doc = "   Pointer to the ::_NV_ENC_PIC_PARAMS structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_BUSY \\n"]
    #[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncEncodePicture(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Lock output bitstream buffer"]
    #[doc = ""]
    #[doc = " This function is used to lock the bitstream buffer to read the encoded data."]
    #[doc = " The client can only access the encoded data by calling this function."]
    #[doc = " The pointer to client accessible encoded data is returned in the"]
    #[doc = " NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr field. The size of the encoded data"]
    #[doc = " in the output buffer is returned in the NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes"]
    #[doc = " The NvEncodeAPI interface also returns the output picture type and picture structure"]
    #[doc = " of the encoded frame in NV_ENC_LOCK_BITSTREAM::pictureType and"]
    #[doc = " NV_ENC_LOCK_BITSTREAM::pictureStruct fields respectively. If the client has"]
    #[doc = " set NV_ENC_LOCK_BITSTREAM::doNotWait to 1, the function might return"]
    #[doc = " ::NV_ENC_ERR_LOCK_BUSY if client is operating in synchronous mode. This is not"]
    #[doc = " a fatal failure if NV_ENC_LOCK_BITSTREAM::doNotWait is set to 1. In the above case the client can"]
    #[doc = " retry the function after few milliseconds."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] lockBitstreamBufferParams"]
    #[doc = "   Pointer to the ::_NV_ENC_LOCK_BITSTREAM structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_LOCK_BUSY \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncLockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unlock the output bitstream buffer"]
    #[doc = ""]
    #[doc = " This function is used to unlock the output bitstream buffer after the client"]
    #[doc = " has read the encoded data from output buffer. The client must call this function"]
    #[doc = " to unlock the output buffer which it has previously locked using ::NvEncLockBitstream()"]
    #[doc = " function. Using a locked bitstream buffer in ::NvEncEncodePicture() API will cause"]
    #[doc = " the function to fail."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] bitstreamBuffer"]
    #[doc = "   bitstream buffer pointer being unlocked"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Locks an input buffer"]
    #[doc = ""]
    #[doc = " This function is used to lock the input buffer to load the uncompressed YUV"]
    #[doc = " pixel data into input buffer memory. The client must pass the NV_ENC_INPUT_PTR"]
    #[doc = " it had previously allocated using ::NvEncCreateInputBuffer()in the"]
    #[doc = " NV_ENC_LOCK_INPUT_BUFFER::inputBuffer field."]
    #[doc = " The NvEncodeAPI interface returns pointer to client accessible input buffer"]
    #[doc = " memory in NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr field."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] lockInputBufferParams"]
    #[doc = "   Pointer to the ::_NV_ENC_LOCK_INPUT_BUFFER structure"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_LOCK_BUSY \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unlocks the input buffer"]
    #[doc = ""]
    #[doc = " This function is used to unlock the input buffer memory previously locked for"]
    #[doc = " uploading YUV pixel data. The input buffer must be unlocked before being used"]
    #[doc = " again for encoding, otherwise NvEncodeAPI will fail the ::NvEncEncodePicture()"]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] inputBuffer"]
    #[doc = "   Pointer to the input buffer that is being unlocked."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    #[doc = ""]
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get encoding statistics."]
    #[doc = ""]
    #[doc = " This function is used to retrieve the encoding statistics."]
    #[doc = " This API is not supported when encode device type is CUDA."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] encodeStats"]
    #[doc = "   Pointer to the ::_NV_ENC_STAT structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get encoded sequence and picture header."]
    #[doc = ""]
    #[doc = " This function can be used to retrieve the sequence and picture header out of"]
    #[doc = " band. The client must call this function only after the encoder has been"]
    #[doc = " initialized using ::NvEncInitializeEncoder() function. The client must"]
    #[doc = " allocate the memory where the NvEncodeAPI interface can copy the bitstream"]
    #[doc = " header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer."]
    #[doc = " The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize."]
    #[doc = " The NvEncodeAPI interface will copy the bitstream header payload and returns"]
    #[doc = " the actual size of the bitstream header in the field"]
    #[doc = " NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize."]
    #[doc = " The client must call  ::NvEncGetSequenceParams() function from the same thread which is"]
    #[doc = " being used to call ::NvEncEncodePicture() function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] sequenceParamPayload"]
    #[doc = "   Pointer to the ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get sequence and picture header."]
    #[doc = ""]
    #[doc = " This function can be used to retrieve the sequence and picture header out of band, even when"]
    #[doc = " encoder has not been initialized using ::NvEncInitializeEncoder() function."]
    #[doc = " The client must allocate the memory where the NvEncodeAPI interface can copy the bitstream"]
    #[doc = " header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer."]
    #[doc = " The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize."]
    #[doc = " If encoder has not been initialized using ::NvEncInitializeEncoder() function, client must"]
    #[doc = " send NV_ENC_INITIALIZE_PARAMS as input. The NV_ENC_INITIALIZE_PARAMS passed must be same as the"]
    #[doc = " one which will be used for initializing encoder using ::NvEncInitializeEncoder() function later."]
    #[doc = " If encoder is already initialized using ::NvEncInitializeEncoder() function, the provided"]
    #[doc = " NV_ENC_INITIALIZE_PARAMS structure is ignored. The NvEncodeAPI interface will copy the bitstream"]
    #[doc = " header payload and returns the actual size of the bitstream header in the field"]
    #[doc = " NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize. The client must call  ::NvEncGetSequenceParamsEx()"]
    #[doc = " function from the same thread which is being used to call ::NvEncEncodePicture() function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] encInitParams"]
    #[doc = "   Pointer to the _NV_ENC_INITIALIZE_PARAMS structure."]
    #[doc = " \\param [in,out] sequenceParamPayload"]
    #[doc = "   Pointer to the ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncGetSequenceParamEx(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Register event for notification to encoding completion."]
    #[doc = ""]
    #[doc = " This function is used to register the completion event with NvEncodeAPI"]
    #[doc = " interface. The event is required when the client has configured the encoder to"]
    #[doc = " work in asynchronous mode. In this mode the client needs to send a completion"]
    #[doc = " event with every output buffer. The NvEncodeAPI interface will signal the"]
    #[doc = " completion of the encoding process using this event. Only after the event is"]
    #[doc = " signaled the client can get the encoded data using ::NvEncLockBitstream() function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] eventParams"]
    #[doc = "   Pointer to the ::_NV_ENC_EVENT_PARAMS structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unregister completion event."]
    #[doc = ""]
    #[doc = " This function is used to unregister completion event which has been previously"]
    #[doc = " registered using ::NvEncRegisterAsyncEvent() function. The client must unregister"]
    #[doc = " all events before destroying the encoder using ::NvEncDestroyEncoder() function."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] eventParams"]
    #[doc = "   Pointer to the ::_NV_ENC_EVENT_PARAMS structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Map an externally created input resource pointer for encoding."]
    #[doc = ""]
    #[doc = " Maps an externally allocated input resource [using and returns a NV_ENC_INPUT_PTR"]
    #[doc = " which can be used for encoding in the ::NvEncEncodePicture() function. The"]
    #[doc = " mapped resource is returned in the field NV_ENC_MAP_INPUT_RESOURCE::outputResourcePtr."]
    #[doc = " The NvEncodeAPI interface also returns the buffer format of the mapped resource"]
    #[doc = " in the field NV_ENC_MAP_INPUT_RESOURCE::outbufferFmt."]
    #[doc = " This function provides synchronization guarantee that any graphics work submitted"]
    #[doc = " on the input buffer is completed before the buffer is used for encoding. This is"]
    #[doc = " also true for compute (i.e. CUDA) work, provided that the previous workload using"]
    #[doc = " the input resource was submitted to the default stream."]
    #[doc = " The client should not access any input buffer while they are mapped by the encoder."]
    #[doc = " For D3D12 interface type, this function does not provide synchronization guarantee."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] mapInputResParams"]
    #[doc = "   Pointer to the ::_NV_ENC_MAP_INPUT_RESOURCE structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n"]
    #[doc = " ::NV_ENC_ERR_MAP_FAILED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncMapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief  UnMaps a NV_ENC_INPUT_PTR  which was mapped for encoding"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " UnMaps an input buffer which was previously mapped using ::NvEncMapInputResource()"]
    #[doc = " API. The mapping created using ::NvEncMapInputResource() should be invalidated"]
    #[doc = " using this API before the external resource is destroyed by the client. The client"]
    #[doc = " must unmap the buffer after ::NvEncLockBitstream() API returns successfully for encode"]
    #[doc = " work submitted using the mapped input buffer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] mappedInputBuffer"]
    #[doc = "   Pointer to the NV_ENC_INPUT_PTR"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n"]
    #[doc = " ::NV_ENC_ERR_RESOURCE_NOT_MAPPED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Destroy Encoding Session"]
    #[doc = ""]
    #[doc = " Destroys the encoder session previously created using ::NvEncOpenEncodeSession()"]
    #[doc = " function. The client must flush the encoder before freeing any resources. In order"]
    #[doc = " to flush the encoder the client must pass a NULL encode picture packet and either"]
    #[doc = " wait for the ::NvEncEncodePicture() function to return in synchronous mode or wait"]
    #[doc = " for the flush event to be signaled by the encoder in asynchronous mode."]
    #[doc = " The client must free all the input and output resources created using the"]
    #[doc = " NvEncodeAPI interface before destroying the encoder. If the client is operating"]
    #[doc = " in asynchronous mode, it must also unregister the completion events previously"]
    #[doc = " registered."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncDestroyEncoder(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Invalidate reference frames"]
    #[doc = ""]
    #[doc = " Invalidates reference frame based on the time stamp provided by the client."]
    #[doc = " The encoder marks any reference frames or any frames which have been reconstructed"]
    #[doc = " using the corrupt frame as invalid for motion estimation and uses older reference"]
    #[doc = " frames for motion estimation. The encoded forces the current frame to be encoded"]
    #[doc = " as an intra frame if no reference frames are left after invalidation process."]
    #[doc = " This is useful for low latency application for error resiliency. The client"]
    #[doc = " is recommended to set NV_ENC_CONFIG_H264::maxNumRefFrames to a large value so"]
    #[doc = " that encoder can keep a backup of older reference frames in the DPB and can use them"]
    #[doc = " for motion estimation when the newer reference frames have been invalidated."]
    #[doc = " This API can be called multiple times."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] invalidRefFrameTimeStamp"]
    #[doc = "   Timestamp of the invalid reference frames which needs to be invalidated."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Opens an encoding session."]
    #[doc = ""]
    #[doc = " Opens an encoding session and returns a pointer to the encoder interface in"]
    #[doc = " the \\p **encoder parameter. The client should start encoding process by calling"]
    #[doc = " this API first."]
    #[doc = " The client must pass a pointer to IDirect3DDevice9 device or CUDA context in the \\p *device parameter."]
    #[doc = " For the OpenGL interface, \\p device must be NULL. An OpenGL context must be current when"]
    #[doc = " calling all NvEncodeAPI functions."]
    #[doc = " If the creation of encoder session fails, the client must call ::NvEncDestroyEncoder API"]
    #[doc = " before exiting."]
    #[doc = ""]
    #[doc = " \\param [in] openSessionExParams"]
    #[doc = "    Pointer to a ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS structure."]
    #[doc = " \\param [out] encoder"]
    #[doc = "    Encode Session pointer to the NvEncodeAPI interface."]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_NO_ENCODE_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Registers a resource with the Nvidia Video Encoder Interface."]
    #[doc = ""]
    #[doc = " Registers a resource with the Nvidia Video Encoder Interface for book keeping."]
    #[doc = " The client is expected to pass the registered resource handle as well, while calling ::NvEncMapInputResource API."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NVEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\param [in] registerResParams"]
    #[doc = "   Pointer to a ::_NV_ENC_REGISTER_RESOURCE structure"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_RESOURCE_REGISTER_FAILED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = " ::NV_ENC_ERR_UNIMPLEMENTED \\n"]
    #[doc = ""]
    pub fn NvEncRegisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unregisters a resource previously registered with the Nvidia Video Encoder Interface."]
    #[doc = ""]
    #[doc = " Unregisters a resource previously registered with the Nvidia Video Encoder Interface."]
    #[doc = " The client is expected to unregister any resource that it has registered with the"]
    #[doc = " Nvidia Video Encoder Interface before destroying the resource."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NVEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\param [in] registeredResource"]
    #[doc = "   The registered resource pointer that was returned in ::NvEncRegisterResource."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = " ::NV_ENC_ERR_UNIMPLEMENTED \\n"]
    #[doc = ""]
    pub fn NvEncUnregisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Reconfigure an existing encoding session."]
    #[doc = ""]
    #[doc = " Reconfigure an existing encoding session."]
    #[doc = " The client should call this API to change/reconfigure the parameter passed during"]
    #[doc = " NvEncInitializeEncoder API call."]
    #[doc = " Currently Reconfiguration of following are not supported."]
    #[doc = " Change in GOP structure."]
    #[doc = " Change in sync-Async mode."]
    #[doc = " Change in MaxWidth & MaxHeight."]
    #[doc = " Change in PTD mode."]
    #[doc = ""]
    #[doc = " Resolution change is possible only if maxEncodeWidth & maxEncodeHeight of NV_ENC_INITIALIZE_PARAMS"]
    #[doc = " is set while creating encoder session."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NVEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\param [in] reInitEncodeParams"]
    #[doc = "    Pointer to a ::NV_ENC_RECONFIGURE_PARAMS structure."]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_NO_ENCODE_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_DEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    #[doc = ""]
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates output MV buffer for ME only mode."]
    #[doc = ""]
    #[doc = " This function is used to allocate an output MV buffer. The size of the mvBuffer is"]
    #[doc = " dependent on the frame height and width of the last ::NvEncCreateInputBuffer() call."]
    #[doc = " The NV_ENC_OUTPUT_PTR returned by the NvEncodeAPI interface in the"]
    #[doc = " ::NV_ENC_CREATE_MV_BUFFER::mvBuffer field should be used in"]
    #[doc = " ::NvEncRunMotionEstimationOnly() API."]
    #[doc = " Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in,out] createMVBufferParams"]
    #[doc = "  Pointer to the ::NV_ENC_CREATE_MV_BUFFER structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release an output MV buffer for ME only mode."]
    #[doc = ""]
    #[doc = " This function is used to release the output MV buffer allocated using"]
    #[doc = " the ::NvEncCreateMVBuffer() function. The client must release the output"]
    #[doc = " mvBuffer using this function before destroying the encoder session."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] mvBuffer"]
    #[doc = "   Pointer to the mvBuffer being released."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Submit an input picture and reference frame for motion estimation in ME only mode."]
    #[doc = ""]
    #[doc = " This function is used to submit the input frame and reference frame for motion"]
    #[doc = " estimation. The ME parameters are passed using *meOnlyParams which is a pointer"]
    #[doc = " to ::_NV_ENC_MEONLY_PARAMS structure."]
    #[doc = " Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data."]
    #[doc = " to get motion vector data."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = " \\param [in] meOnlyParams"]
    #[doc = "   Pointer to the ::_NV_ENC_MEONLY_PARAMS structure."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n"]
    #[doc = " ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n"]
    #[doc = " ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_OUT_OF_MEMORY \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PARAM \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_VERSION \\n"]
    #[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT \\n"]
    #[doc = " ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n"]
    #[doc = " ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get the largest NvEncodeAPI version supported by the driver."]
    #[doc = ""]
    #[doc = " This function can be used by clients to determine if the driver supports"]
    #[doc = " the NvEncodeAPI header the application was compiled with."]
    #[doc = ""]
    #[doc = " \\param [out] version"]
    #[doc = "   Pointer to the requested value. The 4 least significant bits in the returned"]
    #[doc = "   indicate the minor version and the rest of the bits indicate the major"]
    #[doc = "   version of the largest supported version."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS \\n"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR \\n"]
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get the description of the last error reported by the API."]
    #[doc = ""]
    #[doc = " This function returns a null-terminated string that can be used by clients to better understand the reason"]
    #[doc = " for failure of a previous API call."]
    #[doc = ""]
    #[doc = " \\param [in] encoder"]
    #[doc = "   Pointer to the NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "   Pointer to buffer containing the details of the last error encountered by the API."]
    pub fn NvEncGetLastErrorString(
        encoder: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " \\cond API PFN"]
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    #[doc = "< [in]: Client should pass NV_ENCODE_API_FUNCTION_LIST_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and should be set to 0."]
    pub reserved: u32,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDCount() API through this pointer."]
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDCount() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDs() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDs() API through this pointer."]
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormatCount() API through this pointer."]
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormats() API through this pointer."]
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeCaps() API through this pointer."]
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetCount() API through this pointer."]
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetGUIDs() API through this pointer."]
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfig() API through this pointer."]
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    #[doc = "< [out]: Client should access ::NvEncInitializeEncoder() API through this pointer."]
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    #[doc = "< [out]: Client should access ::NvEncCreateInputBuffer() API through this pointer."]
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyInputBuffer() API through this pointer."]
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncCreateBitstreamBuffer() API through this pointer."]
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyBitstreamBuffer() API through this pointer."]
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncEncodePicture() API through this pointer."]
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    #[doc = "< [out]: Client should access ::NvEncLockBitstream() API through this pointer."]
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncUnlockBitstream() API through this pointer."]
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncLockInputBuffer() API through this pointer."]
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncUnlockInputBuffer() API through this pointer."]
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeStats() API through this pointer."]
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParams() API through this pointer."]
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    #[doc = "< [out]: Client should access ::NvEncRegisterAsyncEvent() API through this pointer."]
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncUnregisterAsyncEvent() API through this pointer."]
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncMapInputResource() API through this pointer."]
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnmapInputResource() API through this pointer."]
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncDestroyEncoder() API through this pointer."]
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    #[doc = "< [out]: Client should access ::NvEncInvalidateRefFrames() API through this pointer."]
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    #[doc = "< [out]: Client should access ::NvEncRegisterResource() API through this pointer."]
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnregisterResource() API through this pointer."]
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer."]
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Client should access ::NvEncCreateMVBuffer API through this pointer."]
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer."]
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer."]
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    #[doc = "< [out]: Client should access ::nvEncGetLastErrorString API through this pointer."]
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    #[doc = "< [out]: Client should access ::nvEncSetIOCudaStreams API through this pointer."]
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfigEx() API through this pointer."]
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParamEx() API through this pointer."]
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 277usize],
}
#[test]
fn bindgen_test_layout__NV_ENCODE_API_FUNCTION_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        2552usize,
        concat!("Size of: ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSession
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDCount
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDs
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDs as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormatCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormats
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeCaps as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetCount
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetGUIDs
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetConfig
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInitializeEncoder
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInitializeEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateInputBuffer
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyInputBuffer
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateBitstreamBuffer
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyBitstreamBuffer
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncEncodePicture as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncEncodePicture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockBitstream as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockBitstream
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockInputBuffer
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockInputBuffer
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeStats as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeStats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetSequenceParams
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterAsyncEvent
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterAsyncEvent
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncMapInputResource
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncMapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnmapInputResource
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnmapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyEncoder as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInvalidateRefFrames
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInvalidateRefFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSessionEx
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSessionEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterResource
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterResource
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncReconfigureEncoder
                as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncReconfigureEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved1 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateMVBuffer as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyMVBuffer
                as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRunMotionEstimationOnly
                as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRunMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetLastErrorString
                as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetLastErrorString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncSetIOCudaStreams
                as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncSetIOCudaStreams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetConfigEx
                as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfigEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetSequenceParamEx
                as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParamEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved2 as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _NV_ENCODE_API_FUNCTION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
extern "C" {
    #[doc = " \\ingroup ENCODE_FUNC"]
    #[doc = " Entry Point to the NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " Creates an instance of the NvEncodeAPI interface, and populates the"]
    #[doc = " pFunctionList with function pointers to the API routines implemented by the"]
    #[doc = " NvEncodeAPI interface."]
    #[doc = ""]
    #[doc = " \\param [out] functionList"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::NV_ENC_SUCCESS"]
    #[doc = " ::NV_ENC_ERR_INVALID_PTR"]
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}

const fn nv_struct_version(ver: u32) -> u32 {
    NVENCAPI_VERSION | ((ver) << 16) | (0x7 << 28)
}
pub const NV_ENC_CAPS_PARAM_VER: u32 = nv_struct_version(1);
pub const NV_ENC_ENCODE_OUT_PARAMS_VER: u32 = nv_struct_version(1);
pub const NV_ENC_CREATE_INPUT_BUFFER_VER: u32 = nv_struct_version(1);
pub const NV_ENC_CREATE_BITSTREAM_BUFFER_VER: u32 = nv_struct_version(1);
pub const NV_ENC_CREATE_MV_BUFFER_VER: u32 = nv_struct_version(1);
pub const NV_ENC_RC_PARAMS_VER: u32 = nv_struct_version(1);
pub const NV_ENC_CONFIG_VER: u32 = nv_struct_version(7) | ( 1<<31 );
pub const NV_ENC_INITIALIZE_PARAMS_VER: u32 = nv_struct_version(5) | ( 1<<31 );
pub const NV_ENC_RECONFIGURE_PARAMS_VER: u32 = nv_struct_version(1) | ( 1<<31 );
pub const NV_ENC_PRESET_CONFIG_VER: u32 = nv_struct_version(4) | ( 1<<31 );
pub const NV_ENC_PIC_PARAMS_MVC_VER: u32 = nv_struct_version(1);
pub const NV_ENC_PIC_PARAMS_VER: u32 = nv_struct_version(4) | ( 1<<31 );
pub const NV_ENC_MEONLY_PARAMS_VER: u32 = nv_struct_version(3);
pub const NV_ENC_LOCK_BITSTREAM_VER: u32 = nv_struct_version(1);
pub const NV_ENC_LOCK_INPUT_BUFFER_VER: u32 = nv_struct_version(1);
pub const NV_ENC_MAP_INPUT_RESOURCE_VER: u32 = nv_struct_version(4);
pub const NV_ENC_REGISTER_RESOURCE_VER: u32 = nv_struct_version(3);
pub const NV_ENC_STAT_VER: u32 = nv_struct_version(1);
pub const NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER: u32 = nv_struct_version(1);
pub const NV_ENC_EVENT_PARAMS_VER: u32 = nv_struct_version(1);
pub const NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER: u32 = nv_struct_version(1);
pub const NV_ENCODE_API_FUNCTION_LIST_VER: u32 = nv_struct_version(2);
pub const NV_ENC_CODEC_H264_GUID: GUID = GUID {
    Data1: 0x6bc82762,
    Data2: 0x4e63,
    Data3: 0x4ca4,
    Data4: [0xaa, 0x85, 0x1e, 0x50, 0xf3, 0x21, 0xf6, 0xbf],
};
pub const NV_ENC_CODEC_HEVC_GUID: GUID = GUID {
    Data1: 0x790cdc88,
    Data2: 0x4522,
    Data3: 0x4d7b,
    Data4: [0x94, 0x25, 0xbd, 0xa9, 0x97, 0x5f, 0x76, 0x3],
};
pub const NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID: GUID = GUID {
    Data1: 0xbfd6f8e7,
    Data2: 0x233c,
    Data3: 0x4341,
    Data4: [0x8b, 0x3e, 0x48, 0x18, 0x52, 0x38, 0x3, 0xf4],
};
pub const NV_ENC_H264_PROFILE_BASELINE_GUID: GUID = GUID {
    Data1: 0x727bcaa,
    Data2: 0x78c4,
    Data3: 0x4c83,
    Data4: [0x8c, 0x2f, 0xef, 0x3d, 0xff, 0x26, 0x7c, 0x6a],
};
pub const NV_ENC_H264_PROFILE_MAIN_GUID: GUID = GUID {
    Data1: 0x60b5c1d4,
    Data2: 0x67fe,
    Data3: 0x4790,
    Data4: [0x94, 0xd5, 0xc4, 0x72, 0x6d, 0x7b, 0x6e, 0x6d],
};
pub const NV_ENC_H264_PROFILE_HIGH_GUID: GUID = GUID {
    Data1: 0xe7cbc309,
    Data2: 0x4f7a,
    Data3: 0x4b89,
    Data4: [0xaf, 0x2a, 0xd5, 0x37, 0xc9, 0x2b, 0xe3, 0x10],
};
pub const NV_ENC_H264_PROFILE_HIGH_444_GUID: GUID = GUID {
    Data1: 0x7ac663cb,
    Data2: 0xa598,
    Data3: 0x4960,
    Data4: [0xb8, 0x44, 0x33, 0x9b, 0x26, 0x1a, 0x7d, 0x52],
};
pub const NV_ENC_H264_PROFILE_STEREO_GUID: GUID = GUID {
    Data1: 0x40847bf5,
    Data2: 0x33f7,
    Data3: 0x4601,
    Data4: [0x90, 0x84, 0xe8, 0xfe, 0x3c, 0x1d, 0xb8, 0xb7],
};
pub const NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID: GUID = GUID {
    Data1: 0xb405afac,
    Data2: 0xf32b,
    Data3: 0x417b,
    Data4: [0x89, 0xc4, 0x9a, 0xbe, 0xed, 0x3e, 0x59, 0x78],
};
pub const NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID: GUID = GUID {
    Data1: 0xaec1bd87,
    Data2: 0xe85b,
    Data3: 0x48f2,
    Data4: [0x84, 0xc3, 0x98, 0xbc, 0xa6, 0x28, 0x50, 0x72],
};
pub const NV_ENC_HEVC_PROFILE_MAIN_GUID: GUID = GUID {
    Data1: 0xb514c39a,
    Data2: 0xb55b,
    Data3: 0x40fa,
    Data4: [0x87, 0x8f, 0xf1, 0x25, 0x3b, 0x4d, 0xfd, 0xec],
};
pub const NV_ENC_HEVC_PROFILE_MAIN10_GUID: GUID = GUID {
    Data1: 0xfa4d2b6c,
    Data2: 0x3a5b,
    Data3: 0x411a,
    Data4: [0x80, 0x18, 0x0a, 0x3f, 0x5e, 0x3c, 0x9b, 0xe5],
};
pub const NV_ENC_HEVC_PROFILE_FREXT_GUID: GUID = GUID {
    Data1: 0x51ec32b5,
    Data2: 0x1b4c,
    Data3: 0x453c,
    Data4: [0x9c, 0xbd, 0xb6, 0x16, 0xbd, 0x62, 0x13, 0x41],
};
pub const NV_ENC_PRESET_DEFAULT_GUID: GUID = GUID {
    Data1: 0xb2dfb705,
    Data2: 0x4ebd,
    Data3: 0x4c49,
    Data4: [0x9b, 0x5f, 0x24, 0xa7, 0x77, 0xd3, 0xe5, 0x87],
};
pub const NV_ENC_PRESET_HP_GUID: GUID = GUID {
    Data1: 0x60e4c59f,
    Data2: 0xe846,
    Data3: 0x4484,
    Data4: [0xa5, 0x6d, 0xcd, 0x45, 0xbe, 0x9f, 0xdd, 0xf6],
};
pub const NV_ENC_PRESET_HQ_GUID: GUID = GUID {
    Data1: 0x34dba71d,
    Data2: 0xa77b,
    Data3: 0x4b8f,
    Data4: [0x9c, 0x3e, 0xb6, 0xd5, 0xda, 0x24, 0xc0, 0x12],
};
pub const NV_ENC_PRESET_BD_GUID: GUID = GUID {
    Data1: 0x82e3e450,
    Data2: 0xbdbb,
    Data3: 0x4e40,
    Data4: [0x98, 0x9c, 0x82, 0xa9, 0xd, 0xf9, 0xef, 0x32],
};
pub const NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID: GUID = GUID {
    Data1: 0x49df21c5,
    Data2: 0x6dfa,
    Data3: 0x4feb,
    Data4: [0x97, 0x87, 0x6a, 0xcc, 0x9e, 0xff, 0xb7, 0x26],
};
pub const NV_ENC_PRESET_LOW_LATENCY_HQ_GUID: GUID = GUID {
    Data1: 0xc5f733b9,
    Data2: 0xea97,
    Data3: 0x4cf9,
    Data4: [0xbe, 0xc2, 0xbf, 0x78, 0xa7, 0x4f, 0xd1, 0x5],
};
pub const NV_ENC_PRESET_LOW_LATENCY_HP_GUID: GUID = GUID {
    Data1: 0x67082a44,
    Data2: 0x4bad,
    Data3: 0x48fa,
    Data4: [0x98, 0xea, 0x93, 0x5, 0x6d, 0x15, 0xa, 0x58],
};
pub const NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID: GUID = GUID {
    Data1: 0xd5bfb716,
    Data2: 0xc604,
    Data3: 0x44e7,
    Data4: [0x9b, 0xb8, 0xde, 0xa5, 0x51, 0xf, 0xc3, 0xac],
};
pub const NV_ENC_PRESET_LOSSLESS_HP_GUID: GUID = GUID {
    Data1: 0x149998e7,
    Data2: 0x2364,
    Data3: 0x411d,
    Data4: [0x82, 0xef, 0x17, 0x98, 0x88, 0x9, 0x34, 0x9],
};
pub const NV_ENC_PRESET_P1_GUID: GUID = GUID {
    Data1: 0xfc0a8d3e,
    Data2: 0x45f8,
    Data3: 0x4cf8,
    Data4: [0x80, 0xc7, 0x29, 0x88, 0x71, 0x59, 0xe, 0xbf],
};
pub const NV_ENC_PRESET_P2_GUID: GUID = GUID {
    Data1: 0xf581cfb8,
    Data2: 0x88d6,
    Data3: 0x4381,
    Data4: [0x93, 0xf0, 0xdf, 0x13, 0xf9, 0xc2, 0x7d, 0xab],
};
pub const NV_ENC_PRESET_P3_GUID: GUID = GUID {
    Data1: 0x36850110,
    Data2: 0x3a07,
    Data3: 0x441f,
    Data4: [0x94, 0xd5, 0x36, 0x70, 0x63, 0x1f, 0x91, 0xf6],
};
pub const NV_ENC_PRESET_P4_GUID: GUID = GUID {
    Data1: 0x90a7b826,
    Data2: 0xdf06,
    Data3: 0x4862,
    Data4: [0xb9, 0xd2, 0xcd, 0x6d, 0x73, 0xa0, 0x86, 0x81],
};
pub const NV_ENC_PRESET_P5_GUID: GUID = GUID {
    Data1: 0x21c6e6b4,
    Data2: 0x297a,
    Data3: 0x4cba,
    Data4: [0x99, 0x8f, 0xb6, 0xcb, 0xde, 0x72, 0xad, 0xe3],
};
pub const NV_ENC_PRESET_P6_GUID: GUID = GUID {
    Data1: 0x8e75c279,
    Data2: 0x6299,
    Data3: 0x4ab6,
    Data4: [0x83, 0x2, 0xb, 0x21, 0x5a, 0x33, 0x5c, 0xf5],
};
pub const NV_ENC_PRESET_P7_GUID: GUID = GUID {
    Data1: 0x84848c12,
    Data2: 0x6f71,
    Data3: 0x4c13,
    Data4: [0x93, 0x1b, 0x53, 0xe2, 0x83, 0xf5, 0x79, 0x74],
};
